import sys
import importlib._bootstrap
from _typeshed import Incomplete
from typing import Any, Callable, ClassVar, Literal, overload, Sequence, Self

COMM_NULL: Comm
COMM_SELF: Comm
COMM_WORLD: Comm
CURRENT: int
DECIDE: int
DEFAULT: int
DETERMINE: int
INFINITY: float
NINFINITY: float
PINFINITY: float
UNLIMITED: int
__arch__: str
__pyx_capi__: dict
__type_registry__: dict

class AO(Object):
    class Type:
        ADVANCED: ClassVar[str] = ...
        BASIC: ClassVar[str] = ...
        MAPPING: ClassVar[str] = ...
        MEMORYSCALABLE: ClassVar[str] = ...
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def app2petsc(self, indices: Sequence[int] | IS) -> Sequence[int] | IS: ...
    def createBasic(self, app: Sequence[int] | IS, petsc: Sequence[int] | IS | None = ..., comm: Comm | None = ...) -> Self: ...
    def createMapping(self, app: Sequence[int] | IS, petsc: Sequence[int] | IS | None = ..., comm: Comm | None = ...) -> Self: ...
    def createMemoryScalable(self, app: Sequence[int] | IS, petsc: Sequence[int] | IS | None = ..., comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def getType(self) -> str: ...
    def petsc2app(self, indices: Sequence[int] | IS) -> Sequence[int] | IS: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class CellDM(Object):
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, dm: DM, fields: Sequence[str], coords: Sequence[str]) -> Self: ...
    def destroy(self) -> Self: ...
    def getBlockSize(self, sw: DM) -> int: ...
    def getCellID(self) -> str: ...
    def getCoordinateFields(self) -> list[str]: ...
    def getDM(self) -> DM: ...
    def getFields(self) -> list[str]: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class Comm:
    rank: int
    size: int
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def Barrier(self, *args, **kwargs): ...
    def Clone(self, *args, **kwargs): ...
    def Dup(self, *args, **kwargs): ...
    def Free(self, *args, **kwargs): ...
    def Get_rank(self, *args, **kwargs): ...
    def Get_size(self, *args, **kwargs): ...
    def barrier(self) -> None: ...
    def destroy(self) -> None: ...
    def duplicate(self) -> Self: ...
    def getRank(self) -> int: ...
    def getSize(self) -> int: ...
    def tompi4py(self) -> Intracomm: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class DA(DM):
    class ElementType:
        P1: ClassVar[int] = ...
        Q1: ClassVar[int] = ...

    class InterpolationType:
        Q0: ClassVar[int] = ...
        Q1: ClassVar[int] = ...

    class StencilType:
        BOX: ClassVar[int] = ...
        STAR: ClassVar[int] = ...
    
    boundary_type: DMDA.boundary_type
    corners: DMDA.corners
    dim: DMDA.dim
    dof: DMDA.dof
    ghost_corners: DMDA.ghost_corners
    ghost_ranges: DMDA.ghost_ranges
    proc_sizes: DMDA.proc_sizes
    ranges: DMDA.ranges
    sizes: DMDA.sizes
    stencil: DMDA.stencil
    stencil_type: DMDA.stencil_type
    stencil_width: DMDA.stencil_width
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, dim: int | None = ..., dof: int | None = ..., sizes: DimsSpec | None = ..., proc_sizes: DimsSpec | None = ..., boundary_type: tuple[DM.BoundaryType | int | str | bool, ...] | None = ..., stencil_type: StencilType | None = ..., stencil_width: int | None = ..., setup: bool = ..., ownership_ranges: tuple[Sequence[int], ...] | None = ..., comm: Comm | None = ...) -> Self: ...
    def createNaturalVec(self) -> Vec: ...
    def createNaturalVector(self, *args, **kwargs): ...
    def duplicate(self, dof: int | None = ..., boundary_type: tuple[DM.BoundaryType | int | str | bool, ...] | None = ..., stencil_type: StencilType | None = ..., stencil_width: int | None = ...) -> DMDA: ...
    def getAO(self) -> AO: ...
    def getBoundaryType(self) -> tuple[DM.BoundaryType, ...]: ...
    def getCoordinateName(self, index: int) -> str: ...
    def getCorners(self) -> tuple[tuple[int, ...], tuple[int, ...]]: ...
    def getDim(self) -> int: ...
    def getDof(self) -> int: ...
    def getElementType(self) -> ElementType: ...
    def getElements(self, elem_type: ElementType | None = ...) -> ArrayInt: ...
    def getFieldName(self, field: int) -> str: ...
    def getGhostCorners(self) -> tuple[tuple[int, ...], tuple[int, ...]]: ...
    def getGhostRanges(self) -> tuple[tuple[int, int], ...]: ...
    def getInterpolationType(self) -> InterpolationType: ...
    def getOwnershipRanges(self) -> tuple[ArrayInt, ...]: ...
    def getProcSizes(self) -> tuple[int, ...]: ...
    def getRanges(self) -> tuple[tuple[int, int], ...]: ...
    def getRefinementFactor(self) -> tuple[int, ...]: ...
    def getScatter(self) -> tuple[Scatter, Scatter]: ...
    def getSizes(self) -> tuple[int, ...]: ...
    def getStencil(self) -> tuple[StencilType, int]: ...
    def getStencilType(self) -> StencilType: ...
    def getStencilWidth(self) -> int: ...
    def getVecArray(self, vec: Vec, readonly: bool = ...) -> Any: ...
    def globalToNatural(self, vg: Vec, vn: Vec, addv: InsertMode | None = ...) -> None: ...
    def naturalToGlobal(self, vn: Vec, vg: Vec, addv: InsertMode | None = ...) -> None: ...
    def setBoundaryType(self, boundary_type: tuple[DM.BoundaryType | int | str | bool, ...]) -> None: ...
    def setCoordinateName(self, index: int, name: str) -> None: ...
    def setDim(self, dim: int) -> None: ...
    def setDof(self, dof: int) -> None: ...
    def setElementType(self, elem_type: ElementType | str) -> None: ...
    def setFieldName(self, field: int, name: str) -> None: ...
    def setInterpolationType(self, interp_type: InterpolationType) -> None: ...
    def setProcSizes(self, proc_sizes: DimsSpec) -> None: ...
    def setRefinementFactor(self, refine_x: int = ..., refine_y: int = ..., refine_z: int = ...) -> None: ...
    def setSizes(self, sizes: DimsSpec) -> None: ...
    def setStencil(self, stencil_type: StencilType, stencil_width: int) -> None: ...
    def setStencilType(self, stencil_type: StencilType) -> None: ...
    def setStencilWidth(self, stencil_width: int) -> None: ...
    def setUniformCoordinates(self, xmin: float = ..., xmax: float = ..., ymin: float = ..., ymax: float = ..., zmin: float = ..., zmax: float = ...) -> None: ...

class DM(Object):
    class BoundaryType:
        GHOSTED: ClassVar[int] = ...
        MIRROR: ClassVar[int] = ...
        NONE: ClassVar[int] = ...
        PERIODIC: ClassVar[int] = ...
        TWIST: ClassVar[int] = ...

    class PolytopeType:
        FV_GHOST: ClassVar[int] = ...
        HEXAHEDRON: ClassVar[int] = ...
        INTERIOR_GHOST: ClassVar[int] = ...
        POINT: ClassVar[int] = ...
        POINT_PRISM_TENSOR: ClassVar[int] = ...
        PYRAMID: ClassVar[int] = ...
        QUADRILATERAL: ClassVar[int] = ...
        QUAD_PRISM_TENSOR: ClassVar[int] = ...
        SEGMENT: ClassVar[int] = ...
        SEG_PRISM_TENSOR: ClassVar[int] = ...
        TETRAHEDRON: ClassVar[int] = ...
        TRIANGLE: ClassVar[int] = ...
        TRI_PRISM: ClassVar[int] = ...
        TRI_PRISM_TENSOR: ClassVar[int] = ...
        UNKNOWN: ClassVar[int] = ...
        UNKNOWN_CELL: ClassVar[int] = ...
        UNKNOWN_FACE: ClassVar[int] = ...

    class ReorderDefaultFlag:
        FALSE: ClassVar[int] = ...
        NOTSET: ClassVar[int] = ...
        TRUE: ClassVar[int] = ...

    class Type:
        COMPOSITE: ClassVar[str] = ...
        DA: ClassVar[str] = ...
        FOREST: ClassVar[str] = ...
        MOAB: ClassVar[str] = ...
        NETWORK: ClassVar[str] = ...
        P4EST: ClassVar[str] = ...
        P8EST: ClassVar[str] = ...
        PATCH: ClassVar[str] = ...
        PLEX: ClassVar[str] = ...
        PRODUCT: ClassVar[str] = ...
        REDUNDANT: ClassVar[str] = ...
        SHELL: ClassVar[str] = ...
        SLICED: ClassVar[str] = ...
        STAG: ClassVar[str] = ...
        SWARM: ClassVar[str] = ...
    
    appctx: DM.appctx
    ds: DM.ds
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def adaptLabel(self, label: str) -> DM: ...
    def adaptMetric(self, metric: Vec, bdLabel: str | None = ..., rgLabel: str | None = ...) -> DM: ...
    def addCoarsenHook(self, coarsenhook: DMCoarsenHookFunction, restricthook: DMRestrictHookFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def addField(self, field: Object, label: str | None = ...) -> None: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def clearDS(self) -> None: ...
    def clearFields(self) -> None: ...
    def clearLabelStratum(self, name: str, value: int) -> None: ...
    def clearLabelValue(self, name: str, point: int, value: int) -> None: ...
    def clone(self) -> DM: ...
    def coarsen(self, comm: Comm | None = ...) -> DM: ...
    def coarsenHierarchy(self, nlevels: int) -> list: ...
    def convert(self, dm_type: DM.Type | str) -> DM: ...
    def copyDS(self, dm: DM, minDegree=..., maxDegree=...) -> None: ...
    def copyDisc(self, dm: DM) -> None: ...
    def copyFields(self, dm: DM, minDegree=..., maxDegree=...) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createDS(self) -> None: ...
    def createDefaultSF(self, *args, **kwargs): ...
    def createFieldDecomposition(self) -> tuple[list, list, list]: ...
    def createGlobalVec(self) -> Vec: ...
    def createGlobalVector(self, *args, **kwargs): ...
    def createInjection(self, dm: DM) -> Mat: ...
    def createInterpolation(self, dm: DM) -> tuple[Mat, Vec]: ...
    def createLabel(self, name: str) -> None: ...
    def createLocalVec(self) -> Vec: ...
    def createLocalVector(self, *args, **kwargs): ...
    def createMassMatrix(self, dmf: DM) -> Mat: ...
    def createMat(self) -> Mat: ...
    def createMatrix(self, *args, **kwargs): ...
    def createRestriction(self, dm: DM) -> Mat: ...
    def createSectionSF(self, localsec: Section, globalsec: Section) -> None: ...
    def createSubDM(self, fields: Sequence[int]) -> tuple[IS, DM]: ...
    def destroy(self) -> Self: ...
    def getAppCtx(self) -> Any: ...
    def getAuxiliaryVec(self, label: str | None = ..., value: int | None = ..., part: int | None = ...) -> Vec: ...
    def getBasicAdjacency(self) -> tuple[bool, bool]: ...
    def getBlockSize(self) -> int: ...
    def getBoundingBox(self) -> tuple[tuple[float, float], ...]: ...
    def getCellCoordinateDM(self) -> DM: ...
    def getCellCoordinateSection(self) -> Section: ...
    def getCellCoordinates(self) -> Vec: ...
    def getCellCoordinatesLocal(self) -> Vec: ...
    def getCoarseDM(self) -> DM: ...
    def getCoarsenLevel(self) -> int: ...
    def getCoordinateDM(self) -> DM: ...
    def getCoordinateDim(self) -> int: ...
    def getCoordinateSection(self) -> Section: ...
    def getCoordinates(self) -> Vec: ...
    def getCoordinatesLocal(self) -> Vec: ...
    def getCoordinatesLocalized(self) -> bool: ...
    def getDS(self) -> DS: ...
    def getDefaultGlobalSection(self, *args, **kwargs): ...
    def getDefaultLocalSection(self, *args, **kwargs): ...
    def getDefaultSF(self, *args, **kwargs): ...
    def getDefaultSection(self, *args, **kwargs): ...
    def getDimension(self) -> int: ...
    def getField(self, index: int) -> tuple[Object, None]: ...
    def getFieldAdjacency(self, field: int) -> tuple[bool, bool]: ...
    def getGlobalSection(self) -> Section: ...
    def getGlobalVec(self, name: str | None = ...) -> Vec: ...
    def getLGMap(self) -> LGMap: ...
    def getLabel(self, name: str) -> DMLabel: ...
    def getLabelIdIS(self, name: str) -> IS: ...
    def getLabelName(self, index: int) -> str: ...
    def getLabelOutput(self, name: str) -> bool: ...
    def getLabelSize(self, name: str) -> int: ...
    def getLabelValue(self, name: str, point: int) -> int: ...
    def getLocalBoundingBox(self) -> tuple[tuple[float, float], ...]: ...
    def getLocalSection(self) -> Section: ...
    def getLocalVec(self, name: str | None = ...) -> Vec: ...
    def getMatrix(self, *args, **kwargs): ...
    def getNumFields(self) -> int: ...
    def getNumLabels(self) -> int: ...
    def getOptionsPrefix(self) -> str: ...
    def getPeriodicity(self) -> tuple[ArrayReal, ArrayReal, ArrayReal]: ...
    def getPointSF(self) -> SF: ...
    def getRefineLevel(self) -> int: ...
    def getSection(self, *args, **kwargs): ...
    def getSectionSF(self) -> SF: ...
    def getStratumIS(self, name: str, value: int) -> IS: ...
    def getStratumSize(self, name: str, value: int) -> int: ...
    def getType(self) -> str: ...
    def globalToLocal(self, vg: Vec, vl: Vec, addv: InsertModeSpec | None = ...) -> None: ...
    def hasLabel(self, name: str) -> bool: ...
    def load(self, viewer: Viewer) -> Self: ...
    def localToGlobal(self, vl: Vec, vg: Vec, addv: InsertModeSpec | None = ...) -> None: ...
    def localToLocal(self, vl: Vec, vlg: Vec, addv: InsertModeSpec | None = ...) -> None: ...
    def localizeCoordinates(self) -> None: ...
    def refine(self, comm: Comm | None = ...) -> DM: ...
    def refineHierarchy(self, nlevels: int) -> list: ...
    def removeLabel(self, name: str) -> None: ...
    def restoreGlobalVec(self, vg: Vec, name: str | None = ...) -> None: ...
    def restoreLocalVec(self, vl: Vec, name: str | None = ...) -> None: ...
    def setAppCtx(self, appctx: Any) -> None: ...
    def setAuxiliaryVec(self, aux: Vec, label: DMLabel | None, value=..., part=...) -> None: ...
    def setBasicAdjacency(self, useCone: bool, useClosure: bool) -> None: ...
    def setCellCoordinateDM(self, dm: DM) -> None: ...
    def setCellCoordinateSection(self, dim: int, sec: Section) -> None: ...
    def setCellCoordinates(self, c: Vec) -> None: ...
    def setCellCoordinatesLocal(self, c: Vec) -> None: ...
    def setCoarseDM(self, dm: DM) -> None: ...
    def setCoordinateDim(self, dim: int) -> None: ...
    def setCoordinateDisc(self, disc: FE, project: bool) -> Self: ...
    def setCoordinates(self, c: Vec) -> None: ...
    def setCoordinatesLocal(self, c: Vec) -> None: ...
    def setDefaultGlobalSection(self, *args, **kwargs): ...
    def setDefaultLocalSection(self, *args, **kwargs): ...
    def setDefaultSF(self, *args, **kwargs): ...
    def setDefaultSection(self, *args, **kwargs): ...
    def setDimension(self, dim: int) -> None: ...
    def setField(self, index: int, field: Object, label: str | None = ...) -> None: ...
    def setFieldAdjacency(self, field: int, useCone: bool, useClosure: bool) -> None: ...
    def setFromOptions(self) -> None: ...
    def setGlobalSection(self, sec: Section) -> None: ...
    def setKSPComputeOperators(self, operators, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setLabelOutput(self, name: str, output: bool) -> None: ...
    def setLabelValue(self, name: str, point: int, value: int) -> None: ...
    def setLocalSection(self, sec: Section) -> None: ...
    def setMatType(self, mat_type: Mat.Type | str) -> None: ...
    def setNumFields(self, numFields: int) -> None: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def setPeriodicity(self, maxCell: Sequence[float], Lstart: Sequence[float], L: Sequence[float]) -> None: ...
    def setPointSF(self, sf: SF) -> None: ...
    def setRefineLevel(self, level: int) -> None: ...
    def setSNESFunction(self, function: SNESFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setSNESJacobian(self, jacobian: SNESJacobianFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setSection(self, *args, **kwargs): ...
    def setSectionSF(self, sf: SF) -> None: ...
    def setType(self, dm_type: DM.Type | str) -> None: ...
    def setUp(self) -> Self: ...
    def setVecType(self, vec_type: Vec.Type | str) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class DMComposite(DM):
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def addDM(self, dm: DM, *args: DM) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def gather(self, gvec: Vec, imode: InsertModeSpec, lvecs: Sequence[Vec]) -> None: ...
    def getAccess(self, gvec: Vec, locs: Sequence[int] | None = ...) -> Any: ...
    def getEntries(self) -> list[DM]: ...
    def getGlobalISs(self) -> list[IS]: ...
    def getLGMaps(self) -> list[LGMap]: ...
    def getLocalISs(self) -> list[IS]: ...
    def getNumber(self) -> int: ...
    def getNumberDM(self, *args, **kwargs): ...
    def scatter(self, gvec: Vec, lvecs: Sequence[Vec]) -> None: ...

class DMDA(DM):
    class ElementType:
        P1: ClassVar[int] = ...
        Q1: ClassVar[int] = ...

    class InterpolationType:
        Q0: ClassVar[int] = ...
        Q1: ClassVar[int] = ...

    class StencilType:
        BOX: ClassVar[int] = ...
        STAR: ClassVar[int] = ...
    
    boundary_type: DMDA.boundary_type
    corners: DMDA.corners
    dim: DMDA.dim
    dof: DMDA.dof
    ghost_corners: DMDA.ghost_corners
    ghost_ranges: DMDA.ghost_ranges
    proc_sizes: DMDA.proc_sizes
    ranges: DMDA.ranges
    sizes: DMDA.sizes
    stencil: DMDA.stencil
    stencil_type: DMDA.stencil_type
    stencil_width: DMDA.stencil_width
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, dim: int | None = ..., dof: int | None = ..., sizes: DimsSpec | None = ..., proc_sizes: DimsSpec | None = ..., boundary_type: tuple[DM.BoundaryType | int | str | bool, ...] | None = ..., stencil_type: StencilType | None = ..., stencil_width: int | None = ..., setup: bool = ..., ownership_ranges: tuple[Sequence[int], ...] | None = ..., comm: Comm | None = ...) -> Self: ...
    def createNaturalVec(self) -> Vec: ...
    def createNaturalVector(self, *args, **kwargs): ...
    def duplicate(self, dof: int | None = ..., boundary_type: tuple[DM.BoundaryType | int | str | bool, ...] | None = ..., stencil_type: StencilType | None = ..., stencil_width: int | None = ...) -> DMDA: ...
    def getAO(self) -> AO: ...
    def getBoundaryType(self) -> tuple[DM.BoundaryType, ...]: ...
    def getCoordinateName(self, index: int) -> str: ...
    def getCorners(self) -> tuple[tuple[int, ...], tuple[int, ...]]: ...
    def getDim(self) -> int: ...
    def getDof(self) -> int: ...
    def getElementType(self) -> ElementType: ...
    def getElements(self, elem_type: ElementType | None = ...) -> ArrayInt: ...
    def getFieldName(self, field: int) -> str: ...
    def getGhostCorners(self) -> tuple[tuple[int, ...], tuple[int, ...]]: ...
    def getGhostRanges(self) -> tuple[tuple[int, int], ...]: ...
    def getInterpolationType(self) -> InterpolationType: ...
    def getOwnershipRanges(self) -> tuple[ArrayInt, ...]: ...
    def getProcSizes(self) -> tuple[int, ...]: ...
    def getRanges(self) -> tuple[tuple[int, int], ...]: ...
    def getRefinementFactor(self) -> tuple[int, ...]: ...
    def getScatter(self) -> tuple[Scatter, Scatter]: ...
    def getSizes(self) -> tuple[int, ...]: ...
    def getStencil(self) -> tuple[StencilType, int]: ...
    def getStencilType(self) -> StencilType: ...
    def getStencilWidth(self) -> int: ...
    def getVecArray(self, vec: Vec, readonly: bool = ...) -> Any: ...
    def globalToNatural(self, vg: Vec, vn: Vec, addv: InsertMode | None = ...) -> None: ...
    def naturalToGlobal(self, vn: Vec, vg: Vec, addv: InsertMode | None = ...) -> None: ...
    def setBoundaryType(self, boundary_type: tuple[DM.BoundaryType | int | str | bool, ...]) -> None: ...
    def setCoordinateName(self, index: int, name: str) -> None: ...
    def setDim(self, dim: int) -> None: ...
    def setDof(self, dof: int) -> None: ...
    def setElementType(self, elem_type: ElementType | str) -> None: ...
    def setFieldName(self, field: int, name: str) -> None: ...
    def setInterpolationType(self, interp_type: InterpolationType) -> None: ...
    def setProcSizes(self, proc_sizes: DimsSpec) -> None: ...
    def setRefinementFactor(self, refine_x: int = ..., refine_y: int = ..., refine_z: int = ...) -> None: ...
    def setSizes(self, sizes: DimsSpec) -> None: ...
    def setStencil(self, stencil_type: StencilType, stencil_width: int) -> None: ...
    def setStencilType(self, stencil_type: StencilType) -> None: ...
    def setStencilWidth(self, stencil_width: int) -> None: ...
    def setUniformCoordinates(self, xmin: float = ..., xmax: float = ..., ymin: float = ..., ymax: float = ..., zmin: float = ..., zmax: float = ...) -> None: ...

class DMInterpolation:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def evaluate(self, dm: DM, x: Vec, v: Vec | None = ...) -> Vec: ...
    def getCoordinates(self) -> Vec: ...
    def getDim(self) -> int: ...
    def getDof(self) -> int: ...
    def getVector(self) -> Vec: ...
    def restoreVector(self, vec: Vec) -> None: ...
    def setDim(self, dim: int) -> None: ...
    def setDof(self, dof: int) -> None: ...
    def setUp(self, dm: DM, redundantPoints: bool = ..., ignoreOutsideDomain: bool = ...) -> None: ...

class DMLabel(Object):
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def addStrata(self, strata: Sequence[int]) -> None: ...
    def addStrataIS(self, iset: IS) -> None: ...
    def addStratum(self, value: int) -> None: ...
    def clearStratum(self, stratum: int) -> None: ...
    def clearValue(self, point: int, value: int) -> None: ...
    def computeIndex(self) -> None: ...
    def convertToSection(self) -> tuple[Section, IS]: ...
    def create(self, name: str, comm: Comm | None = ...) -> Self: ...
    def createIndex(self, pStart: int, pEnd: int) -> None: ...
    def destroy(self) -> Self: ...
    def destroyIndex(self) -> None: ...
    def distribute(self, sf: SF) -> DMLabel: ...
    def duplicate(self) -> DMLabel: ...
    def filter(self, start: int, end: int) -> None: ...
    def gather(self, sf: SF) -> DMLabel: ...
    def getBounds(self) -> tuple[int, int]: ...
    def getDefaultValue(self) -> int: ...
    def getNonEmptyStratumValuesIS(self) -> IS: ...
    def getNumValues(self) -> int: ...
    def getStratumIS(self, stratum: int) -> IS: ...
    def getStratumSize(self, stratum: int) -> int: ...
    def getValue(self, point: int) -> int: ...
    def getValueIS(self) -> IS: ...
    def hasPoint(self, point: int) -> bool: ...
    def hasStratum(self, value: int) -> bool: ...
    def hasValue(self, value: int) -> bool: ...
    def insertIS(self, iset: IS, value: int) -> Self: ...
    def permute(self, permutation: IS) -> DMLabel: ...
    def reset(self) -> None: ...
    def setDefaultValue(self, value: int) -> None: ...
    def setStratumIS(self, stratum: int, iset: IS) -> None: ...
    def setValue(self, point: int, value: int) -> None: ...
    def stratumHasPoint(self, value: int, point: int) -> bool: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class DMPlex(DM):
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def computeCellGeometryFVM(self, cell: int) -> tuple[float, ArrayReal, ArrayReal]: ...
    def computeGradientClementInterpolant(self, locX: Vec, locC: Vec) -> Vec: ...
    def constructGhostCells(self, labelName: str | None = ...) -> int: ...
    def coordinatesLoad(self, viewer: Viewer, sfxc: SF) -> None: ...
    def coordinatesView(self, viewer: Viewer) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createBoxMesh(self, faces: Sequence[int], lower: Sequence[float] | None = ..., upper: Sequence[float] | None = ..., simplex: bool | None = ..., periodic: Sequence | str | int | bool | None = ..., interpolate: bool | None = ..., localizationHeight: int | None = ..., sparseLocalize: bool | None = ..., comm: Comm | None = ...) -> Self: ...
    def createBoxSurfaceMesh(self, faces: Sequence[int], lower: Sequence[float] | None = ..., upper: Sequence[float] | None = ..., interpolate: bool | None = ..., comm: Comm | None = ...) -> Self: ...
    def createCGNS(self, cgid: int, interpolate: bool | None = ..., comm: Comm | None = ...) -> Self: ...
    def createCGNSFromFile(self, filename: str, interpolate: bool | None = ..., comm: Comm | None = ...) -> Self: ...
    def createClosureIndex(self, sec: Section) -> None: ...
    def createCoarsePointIS(self) -> IS: ...
    def createCohesiveSubmesh(self, hasLagrange: bool, value: int) -> DMPlex: ...
    def createExodus(self, exoid: int, interpolate: bool | None = ..., comm: Comm | None = ...) -> Self: ...
    def createExodusFromFile(self, filename: str, interpolate: bool | None = ..., comm: Comm | None = ...) -> Self: ...
    def createFromCellList(self, dim: int, cells: Sequence[int], coords: Sequence[float], interpolate: bool | None = ..., comm: Comm | None = ...) -> Self: ...
    def createFromFile(self, filename: str, plexname: str | None = ..., interpolate: bool | None = ..., comm: Comm | None = ...) -> Self: ...
    def createGmsh(self, viewer: Viewer, interpolate: bool | None = ..., comm: Comm | None = ...) -> Self: ...
    def createPointNumbering(self) -> IS: ...
    def createSection(self, numComp: Sequence[int], numDof: Sequence[int], bcField: Sequence[int] | None = ..., bcComps: Sequence[IS] | None = ..., bcPoints: Sequence[IS] | None = ..., perm: IS | None = ...) -> Section: ...
    def distribute(self, overlap: int | None = ...) -> SForNone: ...
    def distributeField(self, sf: SF, sec: Section, vec: Vec, newsec: Section | None = ..., newvec: Vec | None = ...) -> tuple[Section, Vec]: ...
    def distributeGetDefault(self) -> bool: ...
    def distributeOverlap(self, overlap: int | None = ...) -> SF: ...
    def distributeSetDefault(self, flag: bool) -> None: ...
    def distributionGetName(self) -> str: ...
    def distributionSetName(self, name: str) -> None: ...
    def generate(self, boundary: DMPlex, name: str | None = ..., interpolate: bool | None = ...) -> Self: ...
    def getAdjacency(self, p: int) -> ArrayInt: ...
    def getAdjacencyUseAnchors(self) -> bool: ...
    def getCellNumbering(self) -> IS: ...
    def getCellType(self, p: int) -> DM.PolytopeType: ...
    def getCellTypeLabel(self) -> DMLabel: ...
    def getChart(self) -> tuple[int, int]: ...
    def getCone(self, p: int) -> ArrayInt: ...
    def getConeOrientation(self, p: int) -> ArrayInt: ...
    def getConeSize(self, p: int) -> int: ...
    def getDepth(self) -> int: ...
    def getDepthStratum(self, svalue: int) -> tuple[int, int]: ...
    def getFullJoin(self, points: Sequence[int]) -> ArrayInt: ...
    def getHeightStratum(self, svalue: int) -> tuple[int, int]: ...
    def getJoin(self, points: Sequence[int]) -> ArrayInt: ...
    def getMaxSizes(self) -> tuple[int, int]: ...
    def getMeet(self, points: Sequence[int]) -> ArrayInt: ...
    def getMinRadius(self) -> float: ...
    def getOrdering(self, otype: Mat.OrderingType) -> IS: ...
    def getPartitioner(self) -> Partitioner: ...
    def getPointDepth(self, point: int) -> int: ...
    def getPointGlobal(self, point: int) -> tuple[int, int]: ...
    def getPointGlobalField(self, point: int, field: int) -> tuple[int, int]: ...
    def getPointHeight(self, point: int) -> int: ...
    def getPointLocal(self, point: int) -> tuple[int, int]: ...
    def getPointLocalField(self, point: int, field: int) -> tuple[int, int]: ...
    def getRefinementLimit(self) -> float: ...
    def getRefinementUniform(self) -> bool: ...
    def getSubpointIS(self) -> IS: ...
    def getSubpointMap(self) -> DMLabel: ...
    def getSupport(self, p: int) -> ArrayInt: ...
    def getSupportSize(self, p: int) -> int: ...
    def getTransitiveClosure(self, p: int, useCone: bool | None = ...) -> tuple[ArrayInt, ArrayInt]: ...
    def getVecClosure(self, sec: Section, vec: Vec, point: int) -> ArrayScalar: ...
    def getVertexNumbering(self) -> IS: ...
    def globalVectorLoad(self, viewer: Viewer, sectiondm: DM, sf: SF, vec: Vec) -> None: ...
    def globalVectorView(self, viewer: Viewer, sectiondm: DM, vec: Vec) -> None: ...
    def insertCone(self, p: int, conePos: int, conePoint: int) -> None: ...
    def insertConeOrientation(self, p: int, conePos: int, coneOrientation: int) -> None: ...
    def interpolate(self) -> None: ...
    def isDistributed(self) -> bool: ...
    def isSimplex(self) -> bool: ...
    def labelCohesiveComplete(self, label: DMLabel, bdlabel: DMLabel, bdvalue: int, flip: bool, split: bool, subdm: DMPlex) -> None: ...
    def labelComplete(self, label: DMLabel) -> None: ...
    def labelsLoad(self, viewer: Viewer, sfxc: SF) -> None: ...
    def labelsView(self, viewer: Viewer) -> None: ...
    def localVectorLoad(self, viewer: Viewer, sectiondm: DM, sf: SF, vec: Vec) -> None: ...
    def localVectorView(self, viewer: Viewer, sectiondm: DM, vec: Vec) -> None: ...
    def markBoundaryFaces(self, label: str, value: int | None = ...) -> DMLabel: ...
    def metricAverage2(self, metric1: Vec, metric2: Vec, metricAvg: Vec) -> Vec: ...
    def metricAverage3(self, metric1: Vec, metric2: Vec, metric3: Vec, metricAvg: Vec) -> Vec: ...
    def metricCreate(self, field: int | None = ...) -> Vec: ...
    def metricCreateIsotropic(self, indicator: Vec, field: int | None = ...) -> Vec: ...
    def metricCreateUniform(self, alpha: float, field: int | None = ...) -> Vec: ...
    def metricDeterminantCreate(self, field: int | None = ...) -> tuple[Vec, DM]: ...
    def metricEnforceSPD(self, metric: Vec, ometric: Vec, determinant: Vec, restrictSizes: bool | None = ..., restrictAnisotropy: bool | None = ...) -> tuple[Vec, Vec]: ...
    def metricGetGradationFactor(self) -> float: ...
    def metricGetHausdorffNumber(self) -> float: ...
    def metricGetMaximumAnisotropy(self) -> float: ...
    def metricGetMaximumMagnitude(self) -> float: ...
    def metricGetMinimumMagnitude(self) -> float: ...
    def metricGetNormalizationOrder(self) -> float: ...
    def metricGetNumIterations(self) -> int: ...
    def metricGetTargetComplexity(self) -> float: ...
    def metricGetVerbosity(self) -> int: ...
    def metricIntersection2(self, metric1: Vec, metric2: Vec, metricInt: Vec) -> Vec: ...
    def metricIntersection3(self, metric1: Vec, metric2: Vec, metric3: Vec, metricInt: Vec) -> Vec: ...
    def metricIsIsotropic(self) -> bool: ...
    def metricIsUniform(self) -> bool: ...
    def metricNoInsertion(self) -> bool: ...
    def metricNoMovement(self) -> bool: ...
    def metricNoSurf(self) -> bool: ...
    def metricNoSwapping(self) -> bool: ...
    def metricNormalize(self, metric: Vec, ometric: Vec, determinant: Vec, restrictSizes: bool | None = ..., restrictAnisotropy: bool | None = ...) -> tuple[Vec, Vec]: ...
    def metricRestrictAnisotropyFirst(self) -> bool: ...
    def metricSetFromOptions(self) -> None: ...
    def metricSetGradationFactor(self, beta: float) -> None: ...
    def metricSetHausdorffNumber(self, hausd: float) -> None: ...
    def metricSetIsotropic(self, isotropic: bool) -> None: ...
    def metricSetMaximumAnisotropy(self, a_max: float) -> None: ...
    def metricSetMaximumMagnitude(self, h_max: float) -> None: ...
    def metricSetMinimumMagnitude(self, h_min: float) -> None: ...
    def metricSetNoInsertion(self, noInsert: bool) -> None: ...
    def metricSetNoMovement(self, noMove: bool) -> None: ...
    def metricSetNoSurf(self, noSurf: bool) -> None: ...
    def metricSetNoSwapping(self, noSwap: bool) -> None: ...
    def metricSetNormalizationOrder(self, p: float) -> None: ...
    def metricSetNumIterations(self, numIter: int) -> None: ...
    def metricSetRestrictAnisotropyFirst(self, restrictAnisotropyFirst: bool) -> None: ...
    def metricSetTargetComplexity(self, targetComplexity: float) -> None: ...
    def metricSetUniform(self, uniform: bool) -> None: ...
    def metricSetVerbosity(self, verbosity: int) -> None: ...
    def orient(self) -> None: ...
    def permute(self, perm: IS) -> DMPlex: ...
    def rebalanceSharedPoints(self, entityDepth: int | None = ..., useInitialGuess: bool | None = ..., parallel: bool | None = ...) -> bool: ...
    def reorderGetDefault(self) -> DM.ReorderDefaultFlag: ...
    def reorderSetDefault(self, flag: DM.ReorderDefaultFlag) -> None: ...
    def sectionLoad(self, viewer: Viewer, sectiondm: DM, sfxc: SF) -> tuple[SF, SF]: ...
    def sectionView(self, viewer: Viewer, sectiondm: DM) -> None: ...
    def setAdjacencyUseAnchors(self, useAnchors: bool = ...) -> None: ...
    def setCellType(self, p: int, ctype: DM.PolytopeType) -> None: ...
    def setChart(self, pStart: int, pEnd: int) -> None: ...
    def setCone(self, p: int, cone: Sequence[int], orientation: Sequence[int] | None = ...) -> None: ...
    def setConeOrientation(self, p: int, orientation: Sequence[int]) -> None: ...
    def setConeSize(self, p: int, size: int) -> None: ...
    def setMatClosure(self, sec: Section, gsec: Section, mat: Mat, point: int, values: Sequence[Scalar], addv: InsertModeSpec | None = ...) -> None: ...
    def setPartitioner(self, part: Partitioner) -> None: ...
    def setRefinementLimit(self, refinementLimit: float) -> None: ...
    def setRefinementUniform(self, refinementUniform: bool | None = ...) -> None: ...
    def setSupport(self, p: int, supp: Sequence[int]) -> None: ...
    def setSupportSize(self, p: int, size: int) -> None: ...
    def setTetGenOptions(self, opts: str) -> None: ...
    def setTriangleOptions(self, opts: str) -> None: ...
    def setVecClosure(self, sec: Section, vec: Vec, point: int, values: Sequence[Scalar], addv: InsertModeSpec | None = ...) -> None: ...
    def stratify(self) -> None: ...
    def symmetrize(self) -> None: ...
    def topologyLoad(self, viewer: Viewer) -> SF: ...
    def topologyView(self, viewer: Viewer) -> None: ...
    def uninterpolate(self) -> None: ...
    def vecGetClosure(self, sec: Section, vec: Vec, p: int) -> ArrayScalar: ...

class DMPlexTransform(Object):
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def apply(self, dm: DM) -> DM: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def getType(self) -> str: ...
    def setDM(self, dm: DM) -> None: ...
    def setFromOptions(self) -> None: ...
    def setType(self, tr_type: DMPlexTransformType | str) -> None: ...
    def setUp(self) -> Self: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class DMPlexTransformType:
    EXTRUDE: ClassVar[str] = ...
    REFINE1D: ClassVar[str] = ...
    REFINEALFELD: ClassVar[str] = ...
    REFINEBOUNDARYLAYER: ClassVar[str] = ...
    REFINEPOWELLSABIN: ClassVar[str] = ...
    REFINEREGULAR: ClassVar[str] = ...
    REFINESBR: ClassVar[str] = ...
    REFINETOBOX: ClassVar[str] = ...
    REFINETOSIMPLEX: ClassVar[str] = ...
    TRANSFORMFILTER: ClassVar[str] = ...

class DMShell(DM):
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def setCoarsen(self, coarsen: Callable[[DM, Comm], DM] | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setCreateDomainDecomposition(self, decomp: Callable[[DM], tuple[list[str] | None, list[IS] | None, list[IS] | None, list[DM] | None]] | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setCreateDomainDecompositionScatters(self, scatter: Callable[[DM, list[DM]], tuple[list[Scatter], list[Scatter], list[Scatter]]] | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setCreateFieldDecomposition(self, decomp: Callable[[DM], tuple[list[str] | None, list[IS] | None, list[DM] | None]] | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setCreateGlobalVector(self, create_gvec: Callable[[DM], Vec] | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setCreateInjection(self, create_injection: Callable[[DM, DM], Mat] | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setCreateInterpolation(self, create_interpolation: Callable[[DM, DM], tuple[Mat, Vec]] | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setCreateLocalVector(self, create_lvec: Callable[[DM], Vec] | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setCreateMatrix(self, create_matrix: Callable[[DM], Mat] | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setCreateRestriction(self, create_restriction: Callable[[DM, DM], Mat] | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setCreateSubDM(self, create_subdm: Callable[[DM, Sequence[int]], tuple[IS, DM]] | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setGlobalToLocal(self, begin: Callable[[DM, Vec, InsertMode, Vec], None] | None, end: Callable[[DM, Vec, InsertMode, Vec], None] | None, begin_args: tuple[Any, ...] | None = ..., begin_kargs: dict[str, Any] | None = ..., end_args: tuple[Any, ...] | None = ..., end_kargs: dict[str, Any] | None = ...) -> None: ...
    def setGlobalToLocalVecScatter(self, gtol: Scatter) -> None: ...
    def setGlobalVector(self, gv: Vec) -> None: ...
    def setLocalToGlobal(self, begin: Callable[[DM, Vec, InsertMode, Vec], None] | None, end: Callable[[DM, Vec, InsertMode, Vec], None] | None, begin_args: tuple[Any, ...] | None = ..., begin_kargs: dict[str, Any] | None = ..., end_args: tuple[Any, ...] | None = ..., end_kargs: dict[str, Any] | None = ...) -> None: ...
    def setLocalToGlobalVecScatter(self, ltog: Scatter) -> None: ...
    def setLocalToLocal(self, begin: Callable[[DM, Vec, InsertMode, Vec], None] | None, end: Callable[[DM, Vec, InsertMode, Vec], None] | None, begin_args: tuple[Any, ...] | None = ..., begin_kargs: dict[str, Any] | None = ..., end_args: tuple[Any, ...] | None = ..., end_kargs: dict[str, Any] | None = ...) -> None: ...
    def setLocalToLocalVecScatter(self, ltol: Scatter) -> None: ...
    def setLocalVector(self, lv: Vec) -> None: ...
    def setMatrix(self, mat: Mat) -> None: ...
    def setRefine(self, refine: Callable[[DM, Comm], DM] | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...

class DMStag(DM):
    class StencilLocation:
        BACK: ClassVar[int] = ...
        BACK_DOWN: ClassVar[int] = ...
        BACK_DOWN_LEFT: ClassVar[int] = ...
        BACK_DOWN_RIGHT: ClassVar[int] = ...
        BACK_LEFT: ClassVar[int] = ...
        BACK_RIGHT: ClassVar[int] = ...
        BACK_UP: ClassVar[int] = ...
        BACK_UP_LEFT: ClassVar[int] = ...
        BACK_UP_RIGHT: ClassVar[int] = ...
        DOWN: ClassVar[int] = ...
        DOWN_LEFT: ClassVar[int] = ...
        DOWN_RIGHT: ClassVar[int] = ...
        ELEMENT: ClassVar[int] = ...
        FRONT: ClassVar[int] = ...
        FRONT_DOWN: ClassVar[int] = ...
        FRONT_DOWN_LEFT: ClassVar[int] = ...
        FRONT_DOWN_RIGHT: ClassVar[int] = ...
        FRONT_LEFT: ClassVar[int] = ...
        FRONT_RIGHT: ClassVar[int] = ...
        FRONT_UP: ClassVar[int] = ...
        FRONT_UP_LEFT: ClassVar[int] = ...
        FRONT_UP_RIGHT: ClassVar[int] = ...
        LEFT: ClassVar[int] = ...
        NULLLOC: ClassVar[int] = ...
        RIGHT: ClassVar[int] = ...
        UP: ClassVar[int] = ...
        UP_LEFT: ClassVar[int] = ...
        UP_RIGHT: ClassVar[int] = ...

    class StencilType:
        BOX: ClassVar[int] = ...
        NONE: ClassVar[int] = ...
        STAR: ClassVar[int] = ...
    
    boundary_types: DMStag.boundary_types
    corners: DMStag.corners
    dim: DMStag.dim
    dofs: DMStag.dofs
    entries_per_element: DMStag.entries_per_element
    ghost_corners: DMStag.ghost_corners
    global_sizes: DMStag.global_sizes
    local_sizes: DMStag.local_sizes
    proc_sizes: DMStag.proc_sizes
    stencil_type: DMStag.stencil_type
    stencil_width: DMStag.stencil_width
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def VecSplitToDMDA(self, vec: Vec, loc: StencilLocation, c: int) -> tuple[DMDA, Vec]: ...
    def create(self, dim: int, dofs: tuple[int, ...] | None = ..., sizes: tuple[int, ...] | None = ..., boundary_types: tuple[DM.BoundaryType | int | str | bool, ...] | None = ..., stencil_type: StencilType | None = ..., stencil_width: int | None = ..., proc_sizes: tuple[int, ...] | None = ..., ownership_ranges: tuple[Sequence[int], ...] | None = ..., comm: Comm | None = ..., setUp: bool | None = ...) -> Self: ...
    def createCompatibleDMStag(self, dofs: tuple[int, ...]) -> DM: ...
    def get1dCoordinatecArrays(self) -> None: ...
    def getBoundaryTypes(self) -> tuple[str, ...]: ...
    def getCorners(self) -> tuple[tuple[int, ...], tuple[int, ...], tuple[int, ...]]: ...
    def getDim(self) -> int: ...
    def getDof(self) -> tuple[int, ...]: ...
    def getEntriesPerElement(self) -> int: ...
    def getGhostCorners(self) -> tuple[tuple[int, ...], tuple[int, ...]]: ...
    def getGlobalSizes(self) -> tuple[int, ...]: ...
    def getIsFirstRank(self) -> tuple[int, ...]: ...
    def getIsLastRank(self) -> tuple[int, ...]: ...
    def getLocalSizes(self) -> tuple[int, ...]: ...
    def getLocationDof(self, loc: StencilLocation) -> int: ...
    def getLocationSlot(self, loc: StencilLocation, c: int) -> int: ...
    def getOwnershipRanges(self) -> tuple[Sequence[int], ...]: ...
    def getProcSizes(self) -> tuple[int, ...]: ...
    def getProductCoordinateLocationSlot(self, loc: StencilLocation) -> None: ...
    def getStencilType(self) -> str: ...
    def getStencilWidth(self) -> int: ...
    def getVecArray(self, vec: Vec) -> None: ...
    def migrateVec(self, vec: Vec, dmTo: DM, vecTo: Vec) -> None: ...
    def setBoundaryTypes(self, boundary_types: tuple[DM.BoundaryType | int | str | bool, ...]) -> None: ...
    def setCoordinateDMType(self, dmtype: DM.Type) -> None: ...
    def setDof(self, dofs: tuple[int, ...]) -> None: ...
    def setGlobalSizes(self, sizes: tuple[int, ...]) -> None: ...
    def setOwnershipRanges(self, ranges: tuple[Sequence[int], ...]) -> None: ...
    def setProcSizes(self, sizes: tuple[int, ...]) -> None: ...
    def setStencilType(self, stenciltype: StencilType | str) -> None: ...
    def setStencilWidth(self, swidth: int) -> None: ...
    def setUniformCoordinates(self, xmin: float = ..., xmax: float = ..., ymin: float = ..., ymax: float = ..., zmin: float = ..., zmax: float = ...) -> None: ...
    def setUniformCoordinatesExplicit(self, xmin: float = ..., xmax: float = ..., ymin: float = ..., ymax: float = ..., zmin: float = ..., zmax: float = ...) -> None: ...
    def setUniformCoordinatesProduct(self, xmin: float = ..., xmax: float = ..., ymin: float = ..., ymax: float = ..., zmin: float = ..., zmax: float = ...) -> None: ...

class DMSwarm(DM):
    class CollectType:
        COLLECT_BASIC: ClassVar[int] = ...
        COLLECT_DMDABOUNDINGBOX: ClassVar[int] = ...
        COLLECT_GENERAL: ClassVar[int] = ...
        COLLECT_USER: ClassVar[int] = ...

    class MigrateType:
        MIGRATE_BASIC: ClassVar[int] = ...
        MIGRATE_DMCELLEXACT: ClassVar[int] = ...
        MIGRATE_DMCELLNSCATTER: ClassVar[int] = ...
        MIGRATE_USER: ClassVar[int] = ...

    class PICLayoutType:
        LAYOUT_GAUSS: ClassVar[int] = ...
        LAYOUT_REGULAR: ClassVar[int] = ...
        LAYOUT_SUBDIVISION: ClassVar[int] = ...

    class Type:
        BASIC: ClassVar[int] = ...
        PIC: ClassVar[int] = ...
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def addCellDM(self, celldm: CellDM) -> None: ...
    def addNPoints(self, npoints: int) -> None: ...
    def addPoint(self) -> None: ...
    def collectViewCreate(self) -> None: ...
    def collectViewDestroy(self) -> None: ...
    def computeMoments(self, coord: str, weight: str) -> list[float]: ...
    def copyPoint(self, pi: int, pj: int) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createGlobalVectorFromField(self, fieldname: str) -> Vec: ...
    def createGlobalVectorFromFields(self, fieldnames: Sequence[str]) -> Vec: ...
    def createLocalVectorFromField(self, fieldname: str) -> Vec: ...
    def createLocalVectorFromFields(self, fieldnames: Sequence[str]) -> Vec: ...
    def destroyGlobalVectorFromField(self, fieldname: str) -> None: ...
    def destroyGlobalVectorFromFields(self, fieldnames: Sequence[str]) -> None: ...
    def destroyLocalVectorFromField(self, fieldname: str) -> None: ...
    def destroyLocalVectorFromFields(self, fieldnames: Sequence[str]) -> None: ...
    def finalizeFieldRegister(self) -> None: ...
    def getCellDM(self) -> DM: ...
    def getCellDMActive(self) -> CellDM: ...
    def getCellDMByName(self, name: str) -> CellDM: ...
    def getCellDMNames(self) -> list[str]: ...
    def getField(self, fieldname: str) -> Sequence[int | float | complex]: ...
    def getLocalSize(self) -> int: ...
    def getSize(self) -> int: ...
    def initializeFieldRegister(self) -> None: ...
    def insertPointUsingCellDM(self, layoutType: PICLayoutType, fill_param: int) -> None: ...
    def migrate(self, remove_sent_points: bool = ...) -> None: ...
    def projectFields(self, dm: DM, fieldnames: Sequence[str], vecs: Sequence[Vec], mode: ScatterModeSpec = ...) -> None: ...
    def registerField(self, fieldname: str, blocksize: int, dtype: dtype = ...) -> None: ...
    def removePoint(self) -> None: ...
    def removePointAtIndex(self, index: int) -> None: ...
    def restoreField(self, fieldname: str) -> None: ...
    def setCellDM(self, dm: DM) -> None: ...
    def setCellDMActive(self, name: str) -> None: ...
    def setLocalSizes(self, nlocal: int, buffer: int) -> Self: ...
    def setPointCoordinates(self, coordinates: Sequence[float], redundant: bool = ..., mode: InsertMode | None = ...) -> None: ...
    def setPointCoordinatesCellwise(self, coordinates: Sequence[float]) -> None: ...
    def setPointsUniformCoordinates(self, min: Sequence[float], max: Sequence[float], npoints: Sequence[int], mode: InsertMode | None = ...) -> Self: ...
    def setType(self, dmswarm_type: Type | str) -> None: ...
    def sortGetAccess(self) -> None: ...
    def sortGetIsValid(self) -> bool: ...
    def sortGetNumberOfPointsPerCell(self, e: int) -> int: ...
    def sortGetPointsPerCell(self, e: int) -> list[int]: ...
    def sortGetSizes(self) -> tuple[int, int]: ...
    def sortRestoreAccess(self) -> None: ...
    def vectorDefineField(self, fieldname: str) -> None: ...
    def viewFieldsXDMF(self, filename: str, fieldnames: Sequence[str]) -> None: ...
    def viewXDMF(self, filename: str) -> None: ...

class DS(Object):
    class Type:
        BASIC: ClassVar[str] = ...
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def getComponents(self) -> ArrayInt: ...
    def getCoordinateDimension(self) -> int: ...
    def getDimensions(self) -> ArrayInt: ...
    def getFieldIndex(self, disc: Object) -> int: ...
    def getNumFields(self) -> int: ...
    def getSpatialDimension(self) -> int: ...
    def getTotalComponents(self) -> int: ...
    def getTotalDimensions(self) -> int: ...
    def getType(self) -> str: ...
    def setDiscretisation(self, f: int, disc: Object) -> None: ...
    def setFromOptions(self) -> None: ...
    def setType(self, ds_type: Type | str) -> None: ...
    def setUp(self) -> Self: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class Device:
    Type: ClassVar[type[importlib._bootstrap.DeviceType]] = ...
    create: ClassVar[method] = ...
    device_id: Device.device_id
    type: Device.type
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def configure(self) -> None: ...
    def destroy(self) -> None: ...
    def getDeviceId(self) -> int: ...
    def getDeviceType(self) -> str: ...
    @staticmethod
    def setDefaultType(device_type: Type | str) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class DeviceContext(Object):
    JoinMode: ClassVar[type[importlib._bootstrap.DeviceJoinMode]] = ...
    StreamType: ClassVar[type[importlib._bootstrap.StreamType]] = ...
    
    current: DeviceContext.current
    device: DeviceContext.device
    stream_type: DeviceContext.stream_type
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self) -> Self: ...
    def destroy(self) -> Self: ...
    def duplicate(self) -> DeviceContext: ...
    def fork(self, n: int, stream_type: DeviceContext.StreamType | str | None = ...) -> list[DeviceContext]: ...
    @staticmethod
    def getCurrent() -> DeviceContext: ...
    def getDevice(self) -> Device: ...
    def getStreamType(self) -> str: ...
    def idle(self) -> bool: ...
    def join(self, join_mode: DeviceJoinMode | str, py_sub_ctxs: list[DeviceContext]) -> None: ...
    @staticmethod
    def setCurrent(dctx: DeviceContext | None) -> None: ...
    def setDevice(self, device: Device) -> None: ...
    def setFromOptions(self, comm: Comm | None = ...) -> None: ...
    def setStreamType(self, stream_type: StreamType | str) -> None: ...
    def setUp(self) -> None: ...
    def synchronize(self) -> None: ...
    def waitFor(self, other: DeviceContext | None) -> None: ...

class DualSpace(Object):
    class Type:
        BDM: ClassVar[str] = ...
        LAGRANGE: ClassVar[str] = ...
        REFINED: ClassVar[str] = ...
        SIMPLE: ClassVar[str] = ...
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def duplicate(self) -> DualSpace: ...
    def getDM(self) -> DM: ...
    def getDimension(self) -> int: ...
    def getFunctional(self, i: int) -> Quad: ...
    def getInteriorDimension(self) -> int: ...
    def getLagrangeContinuity(self) -> bool: ...
    def getLagrangeTensor(self) -> bool: ...
    def getLagrangeTrimmed(self) -> bool: ...
    def getNumComponents(self) -> int: ...
    def getNumDof(self) -> ArrayInt: ...
    def getOrder(self) -> int: ...
    def getType(self) -> str: ...
    def setDM(self, dm: DM) -> None: ...
    def setLagrangeContinuity(self, continuous: bool) -> None: ...
    def setLagrangeTensor(self, tensor: bool) -> None: ...
    def setLagrangeTrimmed(self, trimmed: bool) -> None: ...
    def setNumComponents(self, nc: int) -> None: ...
    def setOrder(self, order: int) -> None: ...
    def setSimpleDimension(self, dim: int) -> None: ...
    def setSimpleFunctional(self, func: int, functional: Quad) -> None: ...
    def setType(self, dualspace_type: Type | str) -> Self: ...
    def setUp(self) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class Error(RuntimeError):
    def __init__(self, ierr: int = ...) -> Any: ...
    def __bool__(self) -> Any: ...

class FE(Object):
    class Type:
        BASIC: ClassVar[str] = ...
        COMPOSITE: ClassVar[str] = ...
        OPENCL: ClassVar[str] = ...
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createDefault(self, dim: int, nc: int, isSimplex: bool, qorder: int = ..., prefix: str = ..., comm: Comm | None = ...) -> Self: ...
    def createLagrange(self, dim: int, nc: int, isSimplex: bool, k: int, qorder: int = ..., comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def getBasisSpace(self) -> Space: ...
    def getDimension(self) -> int: ...
    def getDualSpace(self) -> DualSpace: ...
    def getFaceQuadrature(self) -> Quad: ...
    def getNumComponents(self) -> int: ...
    def getNumDof(self) -> ndarray: ...
    def getQuadrature(self) -> Quad: ...
    def getSpatialDimension(self) -> int: ...
    def getTileSizes(self, *args, **kwargs): ...
    def setBasisSpace(self, sp: Space) -> None: ...
    def setDualSpace(self, dspace: DualSpace) -> None: ...
    def setFaceQuadrature(self, quad: Quad) -> Quad: ...
    def setFromOptions(self) -> None: ...
    def setNumComponents(self, comp: int) -> None: ...
    def setQuadrature(self, quad: Quad) -> Self: ...
    def setTileSizes(self, blockSize: int, numBlocks: int, batchSize: int, numBatches: int) -> None: ...
    def setType(self, fe_type: Type | str) -> Self: ...
    def setUp(self) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class IS(Object):
    class Type:
        BLOCK: ClassVar[str] = ...
        GENERAL: ClassVar[str] = ...
        STRIDE: ClassVar[str] = ...
    
    array: IS.array
    block_size: IS.block_size
    identity: IS.identity
    indices: IS.indices
    local_size: IS.local_size
    permutation: IS.permutation
    size: IS.size
    sizes: IS.sizes
    sorted: IS.sorted
    __array_interface__: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def allGather(self) -> IS: ...
    def buildTwoSided(self, toindx: IS | None = ...) -> IS: ...
    @overload
    def complement(self, nmin: int, nmax: int) -> IS: ...
    @overload
    def complement(self, oneachprocess) -> Any: ...
    def copy(self, result: IS | None = ...) -> IS: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createBlock(self, bsize: int, indices: Sequence[int], comm: Comm | None = ...) -> Self: ...
    def createGeneral(self, indices: Sequence[int], comm: Comm | None = ...) -> Self: ...
    def createStride(self, size: int, first: int = ..., step: int = ..., comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def difference(self, iset: IS) -> IS: ...
    def duplicate(self) -> IS: ...
    def embed(self, iset: IS, drop: bool) -> IS: ...
    def equal(self, iset: IS) -> bool: ...
    def expand(self, iset: IS) -> IS: ...
    def getBlockIndices(self) -> ArrayInt: ...
    def getBlockSize(self) -> int: ...
    def getIndices(self) -> ArrayInt: ...
    def getInfo(self) -> tuple[int, int]: ...
    def getLocalSize(self) -> int: ...
    def getSize(self) -> int: ...
    def getSizes(self) -> tuple[int, int]: ...
    def getStride(self) -> tuple[int, int, int]: ...
    def getType(self) -> str: ...
    def invertPermutation(self, nlocal: int | None = ...) -> IS: ...
    def isIdentity(self) -> bool: ...
    def isPermutation(self) -> bool: ...
    def isSorted(self) -> bool: ...
    def load(self, viewer: Viewer) -> Self: ...
    def partitioningCount(self, npart: int | None = ...) -> ArrayInt: ...
    def partitioningToNumbering(self) -> IS: ...
    def renumber(self, mult: IS | None = ...) -> tuple[int, IS]: ...
    def setBlockIndices(self, bsize: int, indices: Sequence[int]) -> None: ...
    def setBlockSize(self, bs: int) -> None: ...
    def setIdentity(self) -> Self: ...
    def setIndices(self, indices: Sequence[int]) -> None: ...
    def setPermutation(self) -> Self: ...
    def setStride(self, size: int, first: int = ..., step: int = ...) -> None: ...
    def setType(self, is_type: IS.Type | str) -> None: ...
    def sort(self) -> Self: ...
    def sum(self, iset: IS) -> IS: ...
    def toGeneral(self) -> Self: ...
    def union(self, iset: IS) -> IS: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...
    def __buffer__(self, *args, **kwargs): ...
    def __enter__(self) -> Any: ...
    def __exit__(self, *exc) -> Any: ...
    def __release_buffer__(self, *args, **kwargs): ...

class InsertMode:
    ADD: ClassVar[int] = ...
    ADD_ALL: ClassVar[int] = ...
    ADD_ALL_VALUES: ClassVar[int] = ...
    ADD_BC: ClassVar[int] = ...
    ADD_BC_VALUES: ClassVar[int] = ...
    ADD_VALUES: ClassVar[int] = ...
    INSERT: ClassVar[int] = ...
    INSERT_ALL: ClassVar[int] = ...
    INSERT_ALL_VALUES: ClassVar[int] = ...
    INSERT_BC: ClassVar[int] = ...
    INSERT_BC_VALUES: ClassVar[int] = ...
    INSERT_VALUES: ClassVar[int] = ...
    MAX: ClassVar[int] = ...
    MAX_VALUES: ClassVar[int] = ...
    NOT_SET_VALUES: ClassVar[int] = ...

class KSP(Object):
    class ConvergedReason:
        CONVERGED_ATOL: ClassVar[int] = ...
        CONVERGED_ATOL_NORMAL: ClassVar[int] = ...
        CONVERGED_HAPPY_BREAKDOWN: ClassVar[int] = ...
        CONVERGED_ITERATING: ClassVar[int] = ...
        CONVERGED_ITS: ClassVar[int] = ...
        CONVERGED_NEG_CURVE: ClassVar[int] = ...
        CONVERGED_RTOL: ClassVar[int] = ...
        CONVERGED_RTOL_NORMAL: ClassVar[int] = ...
        CONVERGED_STEP_LENGTH: ClassVar[int] = ...
        DIVERGED_BREAKDOWN: ClassVar[int] = ...
        DIVERGED_BREAKDOWN_BICG: ClassVar[int] = ...
        DIVERGED_DTOL: ClassVar[int] = ...
        DIVERGED_INDEFINITE_MAT: ClassVar[int] = ...
        DIVERGED_INDEFINITE_PC: ClassVar[int] = ...
        DIVERGED_MAX_IT: ClassVar[int] = ...
        DIVERGED_NANORINF: ClassVar[int] = ...
        DIVERGED_NONSYMMETRIC: ClassVar[int] = ...
        DIVERGED_NULL: ClassVar[int] = ...
        DIVERGED_PCSETUP_FAILED: ClassVar[int] = ...
        ITERATING: ClassVar[int] = ...

    class HPDDMType:
        BCG: ClassVar[int] = ...
        BFBCG: ClassVar[int] = ...
        BGCRODR: ClassVar[int] = ...
        BGMRES: ClassVar[int] = ...
        CG: ClassVar[int] = ...
        GCRODR: ClassVar[int] = ...
        GMRES: ClassVar[int] = ...
        PREONLY: ClassVar[int] = ...

    class NormType:
        DEFAULT: ClassVar[int] = ...
        NATURAL: ClassVar[int] = ...
        NO: ClassVar[int] = ...
        NONE: ClassVar[int] = ...
        NORM_DEFAULT: ClassVar[int] = ...
        NORM_NATURAL: ClassVar[int] = ...
        NORM_NONE: ClassVar[int] = ...
        NORM_PRECONDITIONED: ClassVar[int] = ...
        NORM_UNPRECONDITIONED: ClassVar[int] = ...
        PRECONDITIONED: ClassVar[int] = ...
        UNPRECONDITIONED: ClassVar[int] = ...

    class Type:
        BCGS: ClassVar[str] = ...
        BCGSL: ClassVar[str] = ...
        BICG: ClassVar[str] = ...
        CG: ClassVar[str] = ...
        CGLS: ClassVar[str] = ...
        CGNE: ClassVar[str] = ...
        CGS: ClassVar[str] = ...
        CHEBYSHEV: ClassVar[str] = ...
        CR: ClassVar[str] = ...
        DGMRES: ClassVar[str] = ...
        FBCGS: ClassVar[str] = ...
        FBCGSR: ClassVar[str] = ...
        FCG: ClassVar[str] = ...
        FETIDP: ClassVar[str] = ...
        FGMRES: ClassVar[str] = ...
        GCR: ClassVar[str] = ...
        GLTR: ClassVar[str] = ...
        GMRES: ClassVar[str] = ...
        GROPPCG: ClassVar[str] = ...
        HPDDM: ClassVar[str] = ...
        IBCGS: ClassVar[str] = ...
        LCD: ClassVar[str] = ...
        LGMRES: ClassVar[str] = ...
        LSQR: ClassVar[str] = ...
        MINRES: ClassVar[str] = ...
        NASH: ClassVar[str] = ...
        NONE: ClassVar[str] = ...
        PGMRES: ClassVar[str] = ...
        PIPEBCGS: ClassVar[str] = ...
        PIPECG: ClassVar[str] = ...
        PIPECG2: ClassVar[str] = ...
        PIPECGRR: ClassVar[str] = ...
        PIPECR: ClassVar[str] = ...
        PIPEFCG: ClassVar[str] = ...
        PIPEFGMRES: ClassVar[str] = ...
        PIPEGCR: ClassVar[str] = ...
        PIPELCG: ClassVar[str] = ...
        PIPEPRCG: ClassVar[str] = ...
        PREONLY: ClassVar[str] = ...
        PYTHON: ClassVar[str] = ...
        QCG: ClassVar[str] = ...
        QMRCGS: ClassVar[str] = ...
        RICHARDSON: ClassVar[str] = ...
        STCG: ClassVar[str] = ...
        SYMMLQ: ClassVar[str] = ...
        TCQMR: ClassVar[str] = ...
        TFQMR: ClassVar[str] = ...
        TSIRM: ClassVar[str] = ...
    
    appctx: KSP.appctx
    atol: KSP.atol
    divtol: KSP.divtol
    dm: KSP.dm
    guess_knoll: KSP.guess_knoll
    guess_nonzero: KSP.guess_nonzero
    history: KSP.history
    is_converged: KSP.is_converged
    is_diverged: KSP.is_diverged
    is_iterating: KSP.is_iterating
    its: KSP.its
    mat_op: KSP.mat_op
    mat_pc: KSP.mat_pc
    max_it: KSP.max_it
    norm: KSP.norm
    norm_type: KSP.norm_type
    pc: KSP.pc
    pc_side: KSP.pc_side
    reason: KSP.reason
    rtol: KSP.rtol
    vec_rhs: KSP.vec_rhs
    vec_sol: KSP.vec_sol
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def addConvergenceTest(self, converged: KSPConvergenceTestFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ..., prepend: bool = ...) -> None: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def buildResidual(self, r: Vec | None = ...) -> Vec: ...
    def buildSolution(self, x: Vec | None = ...) -> Vec: ...
    def callConvergenceTest(self, its: int, rnorm: float) -> None: ...
    def cancelMonitor(self, *args, **kwargs): ...
    def computeEigenvalues(self) -> ArrayComplex: ...
    def computeExtremeSingularValues(self) -> tuple[float, float]: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createPython(self, context: Any = ..., comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def getAppCtx(self) -> Any: ...
    def getCGObjectiveValue(self) -> float: ...
    def getComputeEigenvalues(self) -> bool: ...
    def getComputeSingularValues(self) -> bool: ...
    def getConvergedReason(self) -> KSP.ConvergedReason: ...
    def getConvergenceHistory(self) -> ArrayReal: ...
    def getConvergenceTest(self) -> KSPConvergenceTestFunction: ...
    def getDM(self) -> DM: ...
    def getErrorIfNotConverged(self) -> bool: ...
    def getHPDDMType(self) -> HPDDMType: ...
    def getInitialGuessKnoll(self) -> bool: ...
    def getInitialGuessNonzero(self) -> bool: ...
    def getIterationNumber(self) -> int: ...
    def getMonitor(self) -> KSPMonitorFunction: ...
    def getNormType(self) -> NormType: ...
    def getOperators(self) -> tuple[Mat, Mat]: ...
    def getOptionsPrefix(self) -> str: ...
    def getPC(self) -> PC: ...
    def getPCSide(self) -> PC.Side: ...
    def getPythonContext(self) -> Any: ...
    def getPythonType(self) -> str: ...
    def getResidualNorm(self) -> float: ...
    def getRhs(self) -> Vec: ...
    def getSolution(self) -> Vec: ...
    def getTolerances(self) -> tuple[float, float, float, int]: ...
    def getType(self) -> str: ...
    def getWorkVecs(self, right: int | None = ..., left: int | None = ...) -> tuple[list[Vec], list[Vec]] | list[Vec] | None: ...
    def logConvergenceHistory(self, rnorm: float) -> None: ...
    def matSolve(self, B: Mat, X: Mat) -> None: ...
    def matSolveTranspose(self, B: Mat, X: Mat) -> None: ...
    def monitor(self, its: int, rnorm: float) -> None: ...
    def monitorCancel(self) -> None: ...
    def reset(self) -> None: ...
    def setAppCtx(self, appctx: Any) -> None: ...
    def setComputeEigenvalues(self, flag: bool) -> None: ...
    def setComputeOperators(self, operators: KSPOperatorsFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setComputeRHS(self, rhs: KSPRHSFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setComputeSingularValues(self, flag: bool) -> None: ...
    def setConvergedReason(self, reason: KSP.ConvergedReason) -> None: ...
    def setConvergenceHistory(self, length: int | None = ..., reset: bool = ...) -> None: ...
    def setConvergenceTest(self, converged: KSPConvergenceTestFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setDM(self, dm: DM) -> None: ...
    @overload
    def setDMActive(self, flag: bool) -> None: ...
    @overload
    def setDMActive(self, _False) -> Any: ...
    def setErrorIfNotConverged(self, flag: bool) -> None: ...
    def setFromOptions(self) -> None: ...
    def setGMRESRestart(self, restart: int) -> None: ...
    def setHPDDMType(self, hpddm_type: HPDDMType) -> None: ...
    def setInitialGuessKnoll(self, flag: bool) -> None: ...
    def setInitialGuessNonzero(self, flag: bool) -> None: ...
    def setIterationNumber(self, its: int) -> None: ...
    def setMonitor(self, monitor: KSPMonitorFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setNormType(self, normtype: NormType) -> None: ...
    def setOperators(self, A: Mat | None = ..., P: Mat | None = ...) -> None: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def setPC(self, pc: PC) -> None: ...
    def setPCSide(self, side: PC.Side) -> None: ...
    def setPostSolve(self, postsolve: KSPPostSolveFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setPreSolve(self, presolve: KSPPreSolveFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setPythonContext(self, context: Any | None = ...) -> None: ...
    def setPythonType(self, py_type: str) -> None: ...
    def setResidualNorm(self, rnorm: float) -> None: ...
    def setTolerances(self, rtol: float | None = ..., atol: float | None = ..., divtol: float | None = ..., max_it: int | None = ...) -> None: ...
    def setType(self, ksp_type: Type | str) -> None: ...
    def setUp(self) -> None: ...
    def setUpOnBlocks(self) -> None: ...
    def setUseFischerGuess(self, model: int, size: int) -> None: ...
    def solve(self, b: Vec, x: Vec) -> None: ...
    def solveTranspose(self, b: Vec, x: Vec) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...
    def __call__(self, *args, **kwargs): ...

class LGMap(Object):
    class MapMode:
        DROP: ClassVar[int] = ...
        MASK: ClassVar[int] = ...

    class Type:
        BASIC: ClassVar[str] = ...
        HASH: ClassVar[str] = ...
    
    block_indices: LGMap.block_indices
    block_info: LGMap.block_info
    block_size: LGMap.block_size
    indices: LGMap.indices
    info: LGMap.info
    size: LGMap.size
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def apply(self, indices: Sequence[int], result: ArrayInt | None = ...) -> ArrayInt: ...
    def applyBlock(self, indices: Sequence[int], result: ArrayInt | None = ...) -> ArrayInt: ...
    def applyBlockInverse(self, indices: Sequence[int], mode: GLMapMode | str | None = ...) -> ArrayInt: ...
    def applyIS(self, iset: IS) -> IS: ...
    def applyInverse(self, indices: Sequence[int], mode: GLMapMode | str | None = ...) -> ArrayInt: ...
    def create(self, indices: Sequence[int], bsize: int | None = ..., comm: Comm | None = ...) -> Self: ...
    def createIS(self, iset: IS) -> Self: ...
    def createSF(self, sf: SF, start: int) -> Self: ...
    def destroy(self) -> Self: ...
    def getBlockIndices(self) -> ArrayInt: ...
    def getBlockInfo(self) -> dict[int, ArrayInt]: ...
    def getBlockSize(self) -> int: ...
    def getIndices(self) -> ArrayInt: ...
    def getInfo(self) -> dict[int, ArrayInt]: ...
    def getSize(self) -> int: ...
    def load(self, viewer: Viewer) -> Self: ...
    def setFromOptions(self) -> None: ...
    def setType(self, lgmap_type: LGMap.Type | str) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...
    def __call__(self, *args, **kwargs): ...

class Log:
    Class: ClassVar[method] = ...
    Event: ClassVar[method] = ...
    EventDecorator: ClassVar[method] = ...
    Stage: ClassVar[method] = ...
    addFlops: ClassVar[method] = ...
    begin: ClassVar[method] = ...
    getCPUTime: ClassVar[method] = ...
    getFlops: ClassVar[method] = ...
    getTime: ClassVar[method] = ...
    isActive: ClassVar[method] = ...
    logFlops: ClassVar[method] = ...
    view: ClassVar[method] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...

class LogClass:
    active: LogClass.active
    id: LogClass.id
    name: LogClass.name
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def activate(self) -> None: ...
    def deactivate(self) -> None: ...
    def getActive(self) -> bool: ...
    def getName(self) -> str: ...
    def setActive(self, flag: bool) -> None: ...
    def __int__(self) -> int: ...

class LogEvent:
    active: LogEvent.active
    active_all: LogEvent.active_all
    id: LogEvent.id
    name: LogEvent.name
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def activate(self) -> None: ...
    def begin(self, *objs) -> None: ...
    def deactivate(self) -> None: ...
    def end(self, *objs) -> None: ...
    def getActive(self) -> bool: ...
    def getActiveAll(self) -> bool: ...
    def getName(self) -> str: ...
    def getPerfInfo(self, stage: int | None = ...) -> dict: ...
    def setActive(self, flag: bool) -> None: ...
    def setActiveAll(self, flag: bool) -> None: ...
    def __enter__(self) -> Any: ...
    def __exit__(self, *exc) -> Any: ...
    def __int__(self) -> int: ...

class LogStage:
    active: LogStage.active
    id: LogStage.id
    name: LogStage.name
    visible: LogStage.visible
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def activate(self) -> None: ...
    def deactivate(self) -> None: ...
    def getActive(self) -> bool: ...
    def getName(self) -> str: ...
    def getVisible(self) -> bool: ...
    def pop(self) -> None: ...
    def push(self) -> None: ...
    def setActive(self, flag: bool) -> None: ...
    def setVisible(self, flag: bool) -> None: ...
    def __enter__(self) -> Any: ...
    def __exit__(self, *exc) -> Any: ...
    def __int__(self) -> int: ...

class Mat(Object):
    class AssemblyType:
        FINAL: ClassVar[int] = ...
        FINAL_ASSEMBLY: ClassVar[int] = ...
        FLUSH: ClassVar[int] = ...
        FLUSH_ASSEMBLY: ClassVar[int] = ...

    class DuplicateOption:
        COPY_VALUES: ClassVar[int] = ...
        DO_NOT_COPY_VALUES: ClassVar[int] = ...
        SHARE_NONZERO_PATTERN: ClassVar[int] = ...

    class FactorShiftType:
        INBLOCKS: ClassVar[int] = ...
        NONE: ClassVar[int] = ...
        NONZERO: ClassVar[int] = ...
        NZ: ClassVar[int] = ...
        PD: ClassVar[int] = ...
        POSITIVE_DEFINITE: ClassVar[int] = ...

    class InfoType:
        GLOBAL_MAX: ClassVar[int] = ...
        GLOBAL_SUM: ClassVar[int] = ...
        LOCAL: ClassVar[int] = ...

    class Option:
        ERROR_LOWER_TRIANGULAR: ClassVar[int] = ...
        FORCE_DIAGONAL_ENTRIES: ClassVar[int] = ...
        GETROW_UPPERTRIANGULAR: ClassVar[int] = ...
        HERMITIAN: ClassVar[int] = ...
        IGNORE_LOWER_TRIANGULAR: ClassVar[int] = ...
        IGNORE_OFF_PROC_ENTRIES: ClassVar[int] = ...
        IGNORE_ZERO_ENTRIES: ClassVar[int] = ...
        KEEP_NONZERO_PATTERN: ClassVar[int] = ...
        NEW_NONZERO_ALLOCATION_ERR: ClassVar[int] = ...
        NEW_NONZERO_LOCATIONS: ClassVar[int] = ...
        NEW_NONZERO_LOCATION_ERR: ClassVar[int] = ...
        NO_OFF_PROC_ENTRIES: ClassVar[int] = ...
        NO_OFF_PROC_ZERO_ROWS: ClassVar[int] = ...
        OPTION_MAX: ClassVar[int] = ...
        OPTION_MIN: ClassVar[int] = ...
        ROW_ORIENTED: ClassVar[int] = ...
        SORTED_FULL: ClassVar[int] = ...
        SPD: ClassVar[int] = ...
        STRUCTURALLY_SYMMETRIC: ClassVar[int] = ...
        STRUCTURE_ONLY: ClassVar[int] = ...
        SUBMAT_SINGLEIS: ClassVar[int] = ...
        SUBSET_OFF_PROC_ENTRIES: ClassVar[int] = ...
        SYMMETRIC: ClassVar[int] = ...
        SYMMETRY_ETERNAL: ClassVar[int] = ...
        UNUSED_NONZERO_LOCATION_ERR: ClassVar[int] = ...
        USE_HASH_TABLE: ClassVar[int] = ...
        USE_INODES: ClassVar[int] = ...

    class OrderingType:
        AMD: ClassVar[str] = ...
        METISND: ClassVar[str] = ...
        NATURAL: ClassVar[str] = ...
        ND: ClassVar[str] = ...
        OWD: ClassVar[str] = ...
        QMD: ClassVar[str] = ...
        RCM: ClassVar[str] = ...
        ROWLENGTH: ClassVar[str] = ...
        SPECTRAL: ClassVar[str] = ...
        WBM: ClassVar[str] = ...

    class SORType:
        APPLY_LOWER: ClassVar[int] = ...
        APPLY_UPPER: ClassVar[int] = ...
        BACKWARD_SWEEP: ClassVar[int] = ...
        EISENSTAT: ClassVar[int] = ...
        FORWARD_SWEEP: ClassVar[int] = ...
        LOCAL_BACKWARD_SWEEP: ClassVar[int] = ...
        LOCAL_FORWARD_SWEEP: ClassVar[int] = ...
        LOCAL_SYMMETRIC_SWEEP: ClassVar[int] = ...
        SYMMETRY_SWEEP: ClassVar[int] = ...
        ZERO_INITIAL_GUESS: ClassVar[int] = ...

    class SolverType:
        BAS: ClassVar[str] = ...
        CHOLMOD: ClassVar[str] = ...
        CUDA: ClassVar[str] = ...
        CUSPARSE: ClassVar[str] = ...
        ELEMENTAL: ClassVar[str] = ...
        ESSL: ClassVar[str] = ...
        KLU: ClassVar[str] = ...
        LUSOL: ClassVar[str] = ...
        MATLAB: ClassVar[str] = ...
        MKL_CPARDISO: ClassVar[str] = ...
        MKL_PARDISO: ClassVar[str] = ...
        MUMPS: ClassVar[str] = ...
        PASTIX: ClassVar[str] = ...
        PETSC: ClassVar[str] = ...
        SCALAPACK: ClassVar[str] = ...
        SPQR: ClassVar[str] = ...
        STRUMPACK: ClassVar[str] = ...
        SUPERLU: ClassVar[str] = ...
        SUPERLU_DIST: ClassVar[str] = ...
        UMFPACK: ClassVar[str] = ...

    class Stencil:
        c: MatStencil.c
        field: MatStencil.field
        i: MatStencil.i
        index: MatStencil.index
        j: MatStencil.j
        k: MatStencil.k
        @classmethod
        def __init__(cls, *args, **kwargs) -> None: ...

    class Structure:
        DIFFERENT: ClassVar[int] = ...
        DIFFERENT_NONZERO_PATTERN: ClassVar[int] = ...
        DIFFERENT_NZ: ClassVar[int] = ...
        SAME: ClassVar[int] = ...
        SAME_NONZERO_PATTERN: ClassVar[int] = ...
        SAME_NZ: ClassVar[int] = ...
        SUBSET: ClassVar[int] = ...
        SUBSET_NONZERO_PATTERN: ClassVar[int] = ...
        SUBSET_NZ: ClassVar[int] = ...
        UNKNOWN: ClassVar[int] = ...
        UNKNOWN_NONZERO_PATTERN: ClassVar[int] = ...
        UNKNOWN_NZ: ClassVar[int] = ...

    class Type:
        AIJ: ClassVar[str] = ...
        AIJCRL: ClassVar[str] = ...
        AIJCUSPARSE: ClassVar[str] = ...
        AIJMKL: ClassVar[str] = ...
        AIJPERM: ClassVar[str] = ...
        AIJSELL: ClassVar[str] = ...
        AIJVIENNACL: ClassVar[str] = ...
        BAIJ: ClassVar[str] = ...
        BAIJMKL: ClassVar[str] = ...
        BLOCKMAT: ClassVar[str] = ...
        COMPOSITE: ClassVar[str] = ...
        CONSTANTDIAGONAL: ClassVar[str] = ...
        DENSE: ClassVar[str] = ...
        DENSECUDA: ClassVar[str] = ...
        DENSEHIP: ClassVar[str] = ...
        DIAGONAL: ClassVar[str] = ...
        DUMMY: ClassVar[str] = ...
        ELEMENTAL: ClassVar[str] = ...
        FFT: ClassVar[str] = ...
        FFTW: ClassVar[str] = ...
        H2OPUS: ClassVar[str] = ...
        HERMITIANTRANSPOSE: ClassVar[str] = ...
        HYPRE: ClassVar[str] = ...
        HYPRESSTRUCT: ClassVar[str] = ...
        HYPRESTRUCT: ClassVar[str] = ...
        IS: ClassVar[str] = ...
        KAIJ: ClassVar[str] = ...
        LMVM: ClassVar[str] = ...
        LMVMBADBROYDEN: ClassVar[str] = ...
        LMVMBFGS: ClassVar[str] = ...
        LMVMBROYDEN: ClassVar[str] = ...
        LMVMDBFGS: ClassVar[str] = ...
        LMVMDDFP: ClassVar[str] = ...
        LMVMDFP: ClassVar[str] = ...
        LMVMDIAGBBROYDEN: ClassVar[str] = ...
        LMVMDQN: ClassVar[str] = ...
        LMVMSR1: ClassVar[str] = ...
        LMVMSYMBADBROYDEN: ClassVar[str] = ...
        LMVMSYMBROYDEN: ClassVar[str] = ...
        LOCALREF: ClassVar[str] = ...
        LRC: ClassVar[str] = ...
        MAIJ: ClassVar[str] = ...
        MFFD: ClassVar[str] = ...
        MPIADJ: ClassVar[str] = ...
        MPIAIJ: ClassVar[str] = ...
        MPIAIJCRL: ClassVar[str] = ...
        MPIAIJCUSPARSE: ClassVar[str] = ...
        MPIAIJMKL: ClassVar[str] = ...
        MPIAIJPERM: ClassVar[str] = ...
        MPIAIJSELL: ClassVar[str] = ...
        MPIAIJVIENNACL: ClassVar[str] = ...
        MPIBAIJ: ClassVar[str] = ...
        MPIBAIJMKL: ClassVar[str] = ...
        MPIDENSE: ClassVar[str] = ...
        MPIDENSECUDA: ClassVar[str] = ...
        MPIDENSEHIP: ClassVar[str] = ...
        MPIKAIJ: ClassVar[str] = ...
        MPIMAIJ: ClassVar[str] = ...
        MPISBAIJ: ClassVar[str] = ...
        MPISELL: ClassVar[str] = ...
        NEST: ClassVar[str] = ...
        NORMAL: ClassVar[str] = ...
        NORMALHERMITIAN: ClassVar[str] = ...
        PREALLOCATOR: ClassVar[str] = ...
        PYTHON: ClassVar[str] = ...
        SAME: ClassVar[str] = ...
        SBAIJ: ClassVar[str] = ...
        SCATTER: ClassVar[str] = ...
        SCHURCOMPLEMENT: ClassVar[str] = ...
        SELL: ClassVar[str] = ...
        SEQAIJ: ClassVar[str] = ...
        SEQAIJCRL: ClassVar[str] = ...
        SEQAIJCUSPARSE: ClassVar[str] = ...
        SEQAIJMKL: ClassVar[str] = ...
        SEQAIJPERM: ClassVar[str] = ...
        SEQAIJSELL: ClassVar[str] = ...
        SEQAIJVIENNACL: ClassVar[str] = ...
        SEQBAIJ: ClassVar[str] = ...
        SEQBAIJMKL: ClassVar[str] = ...
        SEQCUFFT: ClassVar[str] = ...
        SEQDENSE: ClassVar[str] = ...
        SEQDENSECUDA: ClassVar[str] = ...
        SEQDENSEHIP: ClassVar[str] = ...
        SEQKAIJ: ClassVar[str] = ...
        SEQMAIJ: ClassVar[str] = ...
        SEQSBAIJ: ClassVar[str] = ...
        SEQSELL: ClassVar[str] = ...
        SHELL: ClassVar[str] = ...
        SUBMATRIX: ClassVar[str] = ...
        TRANSPOSE: ClassVar[str] = ...
    
    assembled: Mat.assembled
    block_size: Mat.block_size
    block_sizes: Mat.block_sizes
    hermitian: Mat.hermitian
    local_size: Mat.local_size
    owner_range: Mat.owner_range
    owner_ranges: Mat.owner_ranges
    size: Mat.size
    sizes: Mat.sizes
    structsymm: Mat.structsymm
    symmetric: Mat.symmetric
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def H2OpusCompress(self, tol: float) -> Self: ...
    def H2OpusLowRankUpdate(self, U: Mat, V: Mat | None = ..., s: float = ...) -> Self: ...
    def H2OpusOrthogonalize(self) -> Self: ...
    def PtAP(self, *args, **kwargs): ...
    def SOR(self, b: Vec, x: Vec, omega: float = ..., sortype: SORType | None = ..., shift: float = ..., its: int = ..., lits: int = ...) -> None: ...
    def appendOptionsPrefix(self, prefix: str | None = ...) -> None: ...
    def assemble(self, assembly: MatAssemblySpec = ...) -> None: ...
    def assemblyBegin(self, assembly: MatAssemblySpec = ...) -> None: ...
    def assemblyEnd(self, assembly: MatAssemblySpec = ...) -> None: ...
    def axpy(self, alpha: Scalar, X: Mat, structure: Structure = ...) -> None: ...
    def aypx(self, alpha: Scalar, X: Mat, structure: Structure = ...) -> None: ...
    def bindToCPU(self, flg: bool) -> None: ...
    def boundToCPU(self) -> bool: ...
    def chop(self, tol: float) -> None: ...
    def conjugate(self, out: Mat | None = ...) -> Mat: ...
    def convert(self, mat_type: Type | str = ..., out: Mat | None = ...) -> Mat: ...
    def copy(self, result: Mat | None = ..., structure: Structure | None = ...) -> Mat: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createAIJ(self, size: MatSizeSpec, bsize: MatBlockSizeSpec | None = ..., nnz: NNZSpec | None = ..., csr: CSRIndicesSpec | None = ..., comm: Comm | None = ...) -> Self: ...
    def createAIJCRL(self, size: MatSizeSpec, bsize: MatBlockSizeSpec | None = ..., nnz: NNZSpec | None = ..., csr: CSRIndicesSpec | None = ..., comm: Comm | None = ...) -> Self: ...
    def createAIJWithArrays(self, size: MatSizeSpec, csr: CSRSpec | tuple[CSRSpec, CSRSpec], bsize: MatBlockSizeSpec | None = ..., comm: Comm | None = ...) -> Self: ...
    def createBAIJ(self, size: MatSizeSpec, bsize: MatBlockSizeSpec, nnz: NNZSpec | None = ..., csr: CSRIndicesSpec | None = ..., comm: Comm | None = ...) -> Self: ...
    def createConstantDiagonal(self, size: MatSizeSpec, diag: float, comm: Comm | None = ...) -> Self: ...
    def createDense(self, size: MatSizeSpec, bsize: MatBlockSizeSpec | None = ..., array: Sequence[Scalar] | None = ..., comm: Comm | None = ...) -> Self: ...
    def createDenseCUDA(self, size: MatSizeSpec, bsize: MatBlockSizeSpec | None = ..., array: Sequence[Scalar] | None = ..., cudahandle: int | None = ..., comm: Comm | None = ...) -> Self: ...
    def createDiagonal(self, diag: Vec) -> Self: ...
    def createH2OpusFromMat(self, A: Mat, coordinates: Sequence[Scalar] | None = ..., dist: bool | None = ..., eta: float | None = ..., leafsize: int | None = ..., maxrank: int | None = ..., bs: int | None = ..., rtol: float | None = ...) -> Self: ...
    def createHermitianTranspose(self, mat: Mat) -> Self: ...
    def createIS(self, size: MatSizeSpec, bsize: MatBlockSizeSpec | None = ..., lgmapr: LGMap | None = ..., lgmapc: LGMap | None = ..., comm: Comm | None = ...) -> Self: ...
    def createLRC(self, A: Mat | None, U: Mat, c: Vec | None, V: Mat | None) -> Self: ...
    def createNest(self, mats: Sequence[Sequence[Mat]], isrows: Sequence[IS] | None = ..., iscols: Sequence[IS] | None = ..., comm: Comm | None = ...) -> Self: ...
    def createNormal(self, mat: Mat) -> Self: ...
    def createNormalHermitian(self, mat: Mat) -> Self: ...
    def createPython(self, size: MatSizeSpec, context: Any = ..., comm: Comm | None = ...) -> Self: ...
    def createSBAIJ(self, size: MatSizeSpec, bsize: MatBlockSizeSpec, nnz: NNZSpec | None = ..., csr: CSRIndicesSpec | None = ..., comm: Comm | None = ...) -> Self: ...
    def createScatter(self, scatter: Scatter, comm: Comm | None = ...) -> Self: ...
    def createSchurComplement(self, A00: Mat, Ap00: Mat, A01: Mat, A10: Mat, A11: Mat | None = ...) -> Self: ...
    def createSubMatrices(self, isrows: IS | Sequence[IS], iscols: IS | Sequence[IS] = ..., submats: Mat | Sequence[Mat] = ...) -> Sequence[Mat]: ...
    def createSubMatrix(self, isrow: IS, iscol: IS | None = ..., submat: Mat | None = ...) -> Mat: ...
    def createSubMatrixVirtual(self, A: Mat, isrow: IS, iscol: IS | None = ...) -> Self: ...
    def createTranspose(self, mat: Mat) -> Self: ...
    def createVecLeft(self) -> Vec: ...
    def createVecRight(self) -> Vec: ...
    def createVecs(self, side: Literal['r', 'R', 'right', 'Right', 'RIGHT', 'l', 'L', 'left', 'Left', 'LEFT'] | None = ...) -> Vec | tuple[Vec, Vec]: ...
    def destroy(self) -> Self: ...
    def diagonalScale(self, L: Vec | None = ..., R: Vec | None = ...) -> None: ...
    def duplicate(self, copy: bool = ...) -> Mat: ...
    def equal(self, mat: Mat) -> bool: ...
    def factorCholesky(self, isperm: IS, options: dict[str, Any] | None = ...) -> None: ...
    def factorICC(self, isperm: IS, options: dict[str, Any] | None = ...) -> None: ...
    def factorILU(self, isrow: IS, iscol: IS, options: dict[str, Any] | None = ...) -> None: ...
    def factorLU(self, isrow: IS, iscol: IS, options: dict[str, Any] | None = ...) -> None: ...
    def factorNumericCholesky(self, mat: Mat, options=...) -> None: ...
    def factorNumericLU(self, mat: Mat, options=...) -> None: ...
    def factorSymbolicCholesky(self, isperm: IS, options=...) -> None: ...
    def factorSymbolicICC(self, isperm: IS, options=...) -> None: ...
    def factorSymbolicILU(self, isrow: IS, iscol: IS, options=...) -> None: ...
    def factorSymbolicLU(self, mat: Mat, isrow: IS, iscol: IS, options=...) -> None: ...
    def findZeroRows(self) -> IS: ...
    def fixISLocalEmpty(self, fix: bool = ...) -> None: ...
    def getBlockSize(self) -> int: ...
    def getBlockSizes(self) -> tuple[int, int]: ...
    def getColumnIJ(self, symmetric: bool = ..., compressed: bool = ...) -> tuple[ArrayInt, ArrayInt]: ...
    def getColumnVector(self, column: int, result: Vec | None = ...) -> Vec: ...
    def getDM(self) -> DM: ...
    def getDenseArray(self, readonly: bool = ...) -> ArrayScalar: ...
    def getDenseColumnVec(self, i: int, mode: AccessModeSpec = ...) -> Vec: ...
    def getDenseLDA(self) -> int: ...
    def getDenseLocalMatrix(self) -> Mat: ...
    def getDenseSubMatrix(self, rbegin: int = ..., rend: int = ..., cbegin: int = ..., cend: int = ...) -> Mat: ...
    def getDiagonal(self, result: Vec | None = ...) -> Vec: ...
    def getDiagonalBlock(self) -> Mat: ...
    def getISAllowRepeated(self) -> bool: ...
    def getISLocalMat(self) -> Mat: ...
    def getInertia(self) -> tuple[int, int, int]: ...
    def getInfo(self, info: InfoType = ...) -> dict[str, float]: ...
    def getLGMap(self) -> tuple[LGMap, LGMap]: ...
    def getLMVMJ0(self) -> Mat: ...
    def getLMVMJ0KSP(self) -> Mat: ...
    def getLRCMats(self) -> tuple[Mat, Mat, Vec, Mat]: ...
    def getLocalSize(self) -> tuple[int, int]: ...
    def getLocalSubMatrix(self, isrow: IS, iscol: IS, submat: Mat | None = ...) -> Mat: ...
    def getMumpsCntl(self, icntl: int) -> float: ...
    def getMumpsIcntl(self, icntl: int) -> int: ...
    def getMumpsInfo(self, icntl: int) -> int: ...
    def getMumpsInfog(self, icntl: int) -> int: ...
    def getMumpsRinfo(self, icntl: int) -> float: ...
    def getMumpsRinfog(self, icntl: int) -> float: ...
    def getNearNullSpace(self) -> NullSpace: ...
    def getNestISs(self) -> tuple[list[IS], list[IS]]: ...
    def getNestLocalISs(self) -> tuple[list[IS], list[IS]]: ...
    def getNestSize(self) -> tuple[int, int]: ...
    def getNestSubMatrix(self, i: int, j: int) -> Mat: ...
    def getNullSpace(self) -> NullSpace: ...
    def getOption(self, option: Option) -> bool: ...
    def getOptionsPrefix(self) -> str: ...
    def getOrdering(self, ord_type: OrderingType) -> tuple[IS, IS]: ...
    def getOwnershipIS(self) -> tuple[IS, IS]: ...
    def getOwnershipRange(self) -> tuple[int, int]: ...
    def getOwnershipRangeColumn(self) -> tuple[int, int]: ...
    def getOwnershipRanges(self) -> ArrayInt: ...
    def getOwnershipRangesColumn(self) -> ArrayInt: ...
    def getPythonContext(self) -> Any: ...
    def getPythonType(self) -> str: ...
    def getRedundantMatrix(self, nsubcomm: int, subcomm: Comm | None = ..., out: Mat | None = ...) -> Mat: ...
    def getRow(self, row: int) -> tuple[ArrayInt, ArrayScalar]: ...
    def getRowIJ(self, symmetric: bool = ..., compressed: bool = ...) -> tuple[ArrayInt, ArrayInt]: ...
    def getRowSum(self, result: Vec | None = ...) -> Vec: ...
    def getSchurComplementSubMatrices(self) -> tuple[Mat, Mat, Mat, Mat, Mat]: ...
    def getSize(self) -> tuple[int, int]: ...
    def getSizes(self) -> tuple[LayoutSizeSpec, LayoutSizeSpec]: ...
    def getTransposeMat(self) -> Mat: ...
    def getTransposeNullSpace(self) -> NullSpace: ...
    def getType(self) -> str: ...
    def getValue(self, row, col) -> Scalar: ...
    def getValues(self, rows: Sequence[int], cols: Sequence[int], values: ArrayScalar = ...) -> ArrayScalar: ...
    def getValuesCSR(self) -> tuple[ArrayInt, ArrayInt, ArrayScalar]: ...
    def getVecLeft(self, *args, **kwargs): ...
    def getVecRight(self, *args, **kwargs): ...
    def getVecType(self) -> str: ...
    def getVecs(self, *args, **kwargs): ...
    def hermitianTranspose(self, out: Mat | None = ...) -> Mat: ...
    def imagPart(self, out: Mat | None = ...) -> Mat: ...
    def increaseOverlap(self, iset: IS, overlap: int = ...) -> None: ...
    def invertBlockDiagonal(self) -> ArrayScalar: ...
    def isAssembled(self) -> bool: ...
    def isHermitian(self, tol: float = ...) -> bool: ...
    def isHermitianKnown(self) -> tuple[bool, bool]: ...
    def isLinear(self, n: int = ...) -> bool: ...
    def isStructurallySymmetric(self) -> bool: ...
    def isSymmetric(self, tol: float = ...) -> bool: ...
    def isSymmetricKnown(self) -> tuple[bool, bool]: ...
    def isTranspose(self, mat: Mat | None = ..., tol: float = ...) -> bool: ...
    def kron(self, mat: Mat, result: Mat | None = ...) -> Mat: ...
    def load(self, viewer: Viewer) -> Self: ...
    def matMatMult(self, B: Mat, C: Mat, result: Mat | None = ..., fill: float | None = ...) -> Mat: ...
    def matMult(self, mat: Mat, result: Mat | None = ..., fill: float | None = ...) -> Mat: ...
    def matSolve(self, B: Mat, X: Mat) -> None: ...
    def matTransposeMult(self, mat: Mat, result: Mat | None = ..., fill: float | None = ...) -> Mat: ...
    def mult(self, x: Vec, y: Vec) -> None: ...
    def multAdd(self, x: Vec, v: Vec, y: Vec) -> None: ...
    def multHermitian(self, x: Vec, y: Vec) -> None: ...
    def multHermitianAdd(self, x: Vec, v: Vec, y: Vec) -> None: ...
    def multTranspose(self, x: Vec, y: Vec) -> None: ...
    def multTransposeAdd(self, x: Vec, v: Vec, y: Vec) -> None: ...
    def norm(self, norm_type: NormTypeSpec = ...) -> float | tuple[float, float]: ...
    def permute(self, row: IS, col: IS) -> Mat: ...
    def preallocatorPreallocate(self, A: Mat, fill: bool = ...) -> None: ...
    def ptap(self, P: Mat, result: Mat | None = ..., fill: float | None = ...) -> Mat: ...
    def rart(self, R: Mat, result: Mat | None = ..., fill: float | None = ...) -> Mat: ...
    def realPart(self, out: Mat | None = ...) -> Mat: ...
    def reorderForNonzeroDiagonal(self, isrow: IS, iscol: IS, atol: float = ...) -> None: ...
    def restoreDenseColumnVec(self, i: int, mode: AccessModeSpec = ..., V: Vec | None = ...) -> None: ...
    def restoreDenseSubMatrix(self, mat: Mat) -> None: ...
    def restoreISLocalMat(self, local: Mat) -> None: ...
    def restoreLocalSubMatrix(self, isrow: IS, iscol: IS, submat: Mat) -> None: ...
    def retrieveValues(self) -> None: ...
    def scale(self, alpha: Scalar) -> None: ...
    def setBlockSize(self, bsize: int) -> None: ...
    def setBlockSizes(self, row_bsize: int, col_bsize: int) -> None: ...
    def setDM(self, dm: DM) -> None: ...
    def setDenseLDA(self, lda: int) -> None: ...
    def setDiagonal(self, diag: Vec, addv: InsertModeSpec = ...) -> None: ...
    def setFromOptions(self) -> None: ...
    def setISAllowRepeated(self, allow: bool = ...) -> None: ...
    def setISLocalMat(self, local: Mat) -> None: ...
    def setISPreallocation(self, nnz: Sequence[int], onnz: Sequence[int]) -> Self: ...
    def setLGMap(self, rmap: LGMap, cmap: LGMap | None = ...) -> None: ...
    def setLMVMJ0(self, J0: Mat) -> None: ...
    def setLMVMJ0KSP(self, ksp: KSP) -> None: ...
    def setLRCMats(self, A: Mat, U: Mat, c: Vec | None = ..., V: Mat | None = ...) -> None: ...
    def setMumpsCntl(self, icntl: int, val: float) -> None: ...
    def setMumpsIcntl(self, icntl: int, ival: int) -> None: ...
    def setNearNullSpace(self, nsp: NullSpace) -> None: ...
    def setNestVecType(self, vec_type: Vec.Type | str) -> None: ...
    def setNullSpace(self, nsp: NullSpace) -> None: ...
    def setOption(self, option: Option, flag: bool) -> None: ...
    def setOptionsPrefix(self, prefix: str | None = ...) -> None: ...
    def setPreallocationCOO(self, coo_i: Sequence[int], coo_j: Sequence[int]) -> Self: ...
    def setPreallocationCOOLocal(self, coo_i: Sequence[int], coo_j: Sequence[int]) -> Self: ...
    def setPreallocationCSR(self, csr: CSRIndicesSpec) -> Self: ...
    def setPreallocationDense(self, array: Sequence[Scalar]) -> Self: ...
    def setPreallocationNNZ(self, nnz: NNZSpec) -> Self: ...
    def setPythonContext(self, context: Any) -> None: ...
    def setPythonType(self, py_type: str) -> None: ...
    def setRandom(self, random: Random | None = ...) -> None: ...
    @overload
    def setSizes(self, size: MatSizeSpec, bsize: MatBlockSizeSpec | None = ...) -> None: ...
    @overload
    def setSizes(self, n) -> Any: ...
    def setStencil(self, dims: DimsSpec, starts: DimsSpec | None = ..., dof: int = ...) -> None: ...
    def setTransposeNullSpace(self, nsp: NullSpace) -> None: ...
    def setTransposePrecursor(self, out: Mat) -> None: ...
    def setType(self, mat_type: Type | str) -> None: ...
    def setUnfactored(self) -> None: ...
    def setUp(self) -> Self: ...
    def setValue(self, row: int, col: int, value: Scalar, addv: InsertModeSpec = ...) -> None: ...
    def setValueBlockedStagStencil(self, row, col, value, addv=...) -> None: ...
    def setValueBlockedStencil(self, row: Stencil, col: Stencil, value: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValueLocal(self, row: int, col: int, value: Scalar, addv: InsertModeSpec = ...) -> None: ...
    def setValueStagStencil(self, row, col, value, addv=...) -> None: ...
    def setValueStencil(self, row: Stencil, col: Stencil, value: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValues(self, rows: Sequence[int], cols: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesBlocked(self, rows: Sequence[int], cols: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesBlockedCSR(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesBlockedIJV(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = ..., rowmap: Sequence[int] = ...) -> None: ...
    def setValuesBlockedLocal(self, rows: Sequence[int], cols: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesBlockedLocalCSR(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesBlockedLocalIJV(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = ..., rowmap: Sequence[int] = ...) -> None: ...
    def setValuesBlockedLocalRCV(self, R, C, V, addv=...) -> None: ...
    def setValuesBlockedRCV(self, R, C, V, addv=...) -> None: ...
    def setValuesCOO(self, coo_v: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesCSR(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesIJV(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = ..., rowmap: Sequence[int] = ...) -> None: ...
    def setValuesLocal(self, rows: Sequence[int], cols: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesLocalCSR(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesLocalIJV(self, I: Sequence[int], J: Sequence[int], V: Sequence[Scalar], addv: InsertModeSpec = ..., rowmap: Sequence[int] = ...) -> None: ...
    def setValuesLocalRCV(self, R, C, V, addv=...) -> None: ...
    def setValuesRCV(self, R, C, V, addv=...) -> None: ...
    def setVariableBlockSizes(self, blocks: Sequence[int]) -> None: ...
    def setVecType(self, vec_type: Vec.Type | str) -> None: ...
    def shift(self, alpha: Scalar) -> None: ...
    def solve(self, b: Vec, x: Vec) -> None: ...
    def solveAdd(self, b: Vec, y: Vec, x: Vec) -> None: ...
    def solveBackward(self, b: Vec, x: Vec) -> None: ...
    def solveForward(self, b: Vec, x: Vec) -> None: ...
    def solveTranspose(self, b: Vec, x: Vec) -> None: ...
    def solveTransposeAdd(self, b: Vec, y: Vec, x: Vec) -> None: ...
    def storeValues(self) -> None: ...
    def toDLPack(self, mode: AccessModeSpec = ...) -> Any: ...
    def transpose(self, out: Mat | None = ...) -> Mat: ...
    def transposeMatMult(self, mat: Mat, result: Mat | None = ..., fill: float | None = ...) -> Mat: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...
    def zeroEntries(self) -> None: ...
    def zeroRows(self, rows: IS | Sequence[int], diag: Scalar = ..., x: Vec | None = ..., b: Vec | None = ...) -> None: ...
    def zeroRowsColumns(self, rows: IS | Sequence[int], diag: Scalar = ..., x: Vec | None = ..., b: Vec | None = ...) -> None: ...
    def zeroRowsColumnsLocal(self, rows: IS | Sequence[int], diag: Scalar = ..., x: Vec | None = ..., b: Vec | None = ...) -> None: ...
    def zeroRowsColumnsStencil(self, rows: Sequence[Stencil], diag: Scalar = ..., x: Vec | None = ..., b: Vec | None = ...) -> None: ...
    def zeroRowsLocal(self, rows: IS | Sequence[int], diag: Scalar = ..., x: Vec | None = ..., b: Vec | None = ...) -> None: ...
    def __add__(self, other): ...
    def __call__(self, *args, **kwargs): ...
    def __delitem__(self, other) -> None: ...
    def __div__(self, other) -> Any: ...
    def __dlpack__(self, stream=...) -> Any: ...
    def __dlpack_device__(self) -> Any: ...
    def __getitem__(self, index): ...
    def __iadd__(self, other): ...
    def __idiv__(self, other) -> Any: ...
    def __imul__(self, other): ...
    def __isub__(self, other): ...
    def __itruediv__(self, other): ...
    def __matmul__(self, *args, **kwargs): ...
    def __mul__(self, other): ...
    def __neg__(self): ...
    def __pos__(self): ...
    def __radd__(self, other): ...
    def __rdiv__(self, other) -> Any: ...
    def __rmatmul__(self, *args, **kwargs): ...
    def __rmul__(self, other): ...
    def __rsub__(self, other): ...
    def __rtruediv__(self, other): ...
    def __setitem__(self, index, object) -> None: ...
    def __sub__(self, other): ...
    def __truediv__(self, other): ...

class MatPartitioning(Object):
    class Type:
        PARTITIONINGAVERAGE: ClassVar[str] = ...
        PARTITIONINGCHACO: ClassVar[str] = ...
        PARTITIONINGCURRENT: ClassVar[str] = ...
        PARTITIONINGHIERARCH: ClassVar[str] = ...
        PARTITIONINGPARMETIS: ClassVar[str] = ...
        PARTITIONINGPARTY: ClassVar[str] = ...
        PARTITIONINGPTSCOTCH: ClassVar[str] = ...
        PARTITIONINGSQUARE: ClassVar[str] = ...
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def apply(self, partitioning: IS) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def getType(self) -> str: ...
    def setAdjacency(self, adj: Mat) -> None: ...
    def setFromOptions(self) -> None: ...
    def setType(self, matpartitioning_type: Type | str) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...
    def __call__(self, *args, **kwargs): ...

class NormType:
    FRB: ClassVar[int] = ...
    FROBENIUS: ClassVar[int] = ...
    INF: ClassVar[int] = ...
    INFINITY: ClassVar[int] = ...
    MAX: ClassVar[int] = ...
    N1: ClassVar[int] = ...
    N12: ClassVar[int] = ...
    N2: ClassVar[int] = ...
    NORM_1: ClassVar[int] = ...
    NORM_1_AND_2: ClassVar[int] = ...
    NORM_2: ClassVar[int] = ...
    NORM_FROBENIUS: ClassVar[int] = ...
    NORM_INFINITY: ClassVar[int] = ...
    NORM_MAX: ClassVar[int] = ...

class NullSpace(Object):
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, constant: bool = ..., vectors: Sequence[Vec] = ..., comm=...) -> Self: ...
    def createRigidBody(self, coords: Vec) -> Self: ...
    def destroy(self) -> Self: ...
    def getFunction(self) -> MatNullFunction: ...
    def getVecs(self) -> list[Vec]: ...
    def hasConstant(self) -> bool: ...
    def remove(self, vec: Vec) -> None: ...
    def setFunction(self, function: MatNullFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def test(self, mat: Mat) -> bool: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...
    def __call__(self, *args, **kwargs): ...

class Object:
    
    classid: Object.classid
    comm: Object.comm
    fortran: Object.fortran
    handle: Object.handle
    id: Object.id
    klass: Object.klass
    name: Object.name
    prefix: Object.prefix
    refcount: Object.refcount
    type: Object.type
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def compose(self, name: str | None, obj: Object) -> None: ...
    def decRef(self) -> int: ...
    def destroy(self) -> Self: ...
    def destroyOptionsHandlers(self) -> None: ...
    def getAttr(self, name: str) -> object: ...
    def getClassId(self) -> int: ...
    def getClassName(self) -> str: ...
    def getComm(self) -> Comm: ...
    def getDict(self) -> dict: ...
    def getId(self) -> int: ...
    def getName(self) -> str: ...
    def getOptionsPrefix(self) -> str: ...
    def getRefCount(self) -> int: ...
    def getTabLevel(self) -> None: ...
    def getType(self) -> str: ...
    def incRef(self) -> int: ...
    def incrementTabLevel(self, tab: int, parent: Object | None = ...) -> None: ...
    def query(self, name: str) -> Object: ...
    def setAttr(self, name: str, attr: object) -> None: ...
    def setFromOptions(self) -> None: ...
    def setName(self, name: str | None) -> None: ...
    def setOptionsHandler(self, handler: PetscOptionsHandlerFunction | None) -> None: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def setTabLevel(self, level: int) -> None: ...
    def stateGet(self) -> int: ...
    def stateIncrease(self) -> None: ...
    def stateSet(self, state: int) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...
    def viewFromOptions(self, name: str, objpre: Object | None = ...) -> None: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> Any: ...
    def __deepcopy__(self, memo: dict) -> Any: ...
    def __eq__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...

class Options:
    prefix: Options.prefix
    @overload
    def __init__(self) -> Any: ...
    @overload
    def __init__(self) -> Any: ...
    def clear(self) -> Self: ...
    def create(self) -> Self: ...
    def delValue(self, name: str) -> None: ...
    def destroy(self) -> Self: ...
    def getAll(self) -> dict[str, str]: ...
    def getBool(self, name: str, default=...) -> bool: ...
    def getBoolArray(self, name: str, default=...) -> ArrayBool: ...
    def getInt(self, name: str, default=...) -> int: ...
    def getIntArray(self, name: str, default=...) -> ArrayInt: ...
    def getReal(self, name: str, default=...) -> float: ...
    def getRealArray(self, name: str, default=...) -> ArrayReal: ...
    def getScalar(self, name: str, default=...) -> Scalar: ...
    def getScalarArray(self, name: str, default=...) -> ArrayScalar: ...
    def getString(self, name: str, default=...) -> str: ...
    def hasName(self, name: str) -> bool: ...
    def insertString(self, string: str) -> None: ...
    def prefixPop(self) -> None: ...
    def prefixPush(self, prefix: str | Options | Object | None) -> None: ...
    def setValue(self, name: str, value: bool | int | float | Scalar | Sequence[bool] | Sequence[int] | Sequence[float] | Sequence[Scalar] | str) -> None: ...
    def used(self, name: str) -> bool: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...
    def __contains__(self, other) -> bool: ...
    def __delitem__(self, other) -> None: ...
    def __getitem__(self, index): ...
    def __setitem__(self, index, object) -> None: ...

class PC(Object):
    class ASMType:
        BASIC: ClassVar[int] = ...
        INTERPOLATE: ClassVar[int] = ...
        NONE: ClassVar[int] = ...
        RESTRICT: ClassVar[int] = ...

    class CompositeType:
        ADDITIVE: ClassVar[int] = ...
        MULTIPLICATIVE: ClassVar[int] = ...
        SCHUR: ClassVar[int] = ...
        SPECIAL: ClassVar[int] = ...
        SYMMETRIC_MULTIPLICATIVE: ClassVar[int] = ...

    class DeflationSpaceType:
        AGGREGATION: ClassVar[int] = ...
        BIORTH22: ClassVar[int] = ...
        DB16: ClassVar[int] = ...
        DB2: ClassVar[int] = ...
        DB4: ClassVar[int] = ...
        DB8: ClassVar[int] = ...
        HAAR: ClassVar[int] = ...
        MEYER: ClassVar[int] = ...
        USER: ClassVar[int] = ...

    class FailedReason:
        FACTOR_NUMERIC_ZEROPIVOT: ClassVar[int] = ...
        FACTOR_OTHER: ClassVar[int] = ...
        FACTOR_OUTMEMORY: ClassVar[int] = ...
        FACTOR_STRUCT_ZEROPIVOT: ClassVar[int] = ...
        NOERROR: ClassVar[int] = ...
        SETUP_ERROR: ClassVar[int] = ...
        SUBPC_ERROR: ClassVar[int] = ...

    class FieldSplitSchurFactType:
        DIAG: ClassVar[int] = ...
        FULL: ClassVar[int] = ...
        LOWER: ClassVar[int] = ...
        UPPER: ClassVar[int] = ...

    class FieldSplitSchurPreType:
        A11: ClassVar[int] = ...
        FULL: ClassVar[int] = ...
        SELF: ClassVar[int] = ...
        SELFP: ClassVar[int] = ...
        USER: ClassVar[int] = ...

    class GAMGType:
        AGG: ClassVar[str] = ...
        CLASSICAL: ClassVar[str] = ...
        GEO: ClassVar[str] = ...

    class GASMType:
        BASIC: ClassVar[int] = ...
        INTERPOLATE: ClassVar[int] = ...
        NONE: ClassVar[int] = ...
        RESTRICT: ClassVar[int] = ...

    class HPDDMCoarseCorrectionType:
        ADDITIVE: ClassVar[int] = ...
        BALANCED: ClassVar[int] = ...
        DEFLATED: ClassVar[int] = ...
        NONE: ClassVar[int] = ...

    class MGCycleType:
        V: ClassVar[int] = ...
        W: ClassVar[int] = ...

    class MGType:
        ADDITIVE: ClassVar[int] = ...
        FULL: ClassVar[int] = ...
        KASKADE: ClassVar[int] = ...
        MULTIPLICATIVE: ClassVar[int] = ...

    class PatchConstructType:
        PARDECOMP: ClassVar[int] = ...
        PYTHON: ClassVar[int] = ...
        STAR: ClassVar[int] = ...
        USER: ClassVar[int] = ...
        VANKA: ClassVar[int] = ...

    class SchurFactType:
        DIAG: ClassVar[int] = ...
        FULL: ClassVar[int] = ...
        LOWER: ClassVar[int] = ...
        UPPER: ClassVar[int] = ...

    class SchurPreType:
        A11: ClassVar[int] = ...
        FULL: ClassVar[int] = ...
        SELF: ClassVar[int] = ...
        SELFP: ClassVar[int] = ...
        USER: ClassVar[int] = ...

    class Side:
        L: ClassVar[int] = ...
        LEFT: ClassVar[int] = ...
        R: ClassVar[int] = ...
        RIGHT: ClassVar[int] = ...
        S: ClassVar[int] = ...
        SYMMETRIC: ClassVar[int] = ...

    class Type:
        ASM: ClassVar[str] = ...
        BDDC: ClassVar[str] = ...
        BJACOBI: ClassVar[str] = ...
        CHOLESKY: ClassVar[str] = ...
        CHOWILUVIENNACL: ClassVar[str] = ...
        COMPOSITE: ClassVar[str] = ...
        CP: ClassVar[str] = ...
        DEFLATION: ClassVar[str] = ...
        EISENSTAT: ClassVar[str] = ...
        EXOTIC: ClassVar[str] = ...
        FIELDSPLIT: ClassVar[str] = ...
        GALERKIN: ClassVar[str] = ...
        GAMG: ClassVar[str] = ...
        GASM: ClassVar[str] = ...
        H2OPUS: ClassVar[str] = ...
        HMG: ClassVar[str] = ...
        HPDDM: ClassVar[str] = ...
        HYPRE: ClassVar[str] = ...
        ICC: ClassVar[str] = ...
        ILU: ClassVar[str] = ...
        JACOBI: ClassVar[str] = ...
        KACZMARZ: ClassVar[str] = ...
        KSP: ClassVar[str] = ...
        LMVM: ClassVar[str] = ...
        LSC: ClassVar[str] = ...
        LU: ClassVar[str] = ...
        MAT: ClassVar[str] = ...
        MG: ClassVar[str] = ...
        ML: ClassVar[str] = ...
        NN: ClassVar[str] = ...
        NONE: ClassVar[str] = ...
        PARMS: ClassVar[str] = ...
        PATCH: ClassVar[str] = ...
        PBJACOBI: ClassVar[str] = ...
        PFMG: ClassVar[str] = ...
        PYTHON: ClassVar[str] = ...
        QR: ClassVar[str] = ...
        REDISTRIBUTE: ClassVar[str] = ...
        REDUNDANT: ClassVar[str] = ...
        ROWSCALINGVIENNACL: ClassVar[str] = ...
        SAVIENNACL: ClassVar[str] = ...
        SHELL: ClassVar[str] = ...
        SOR: ClassVar[str] = ...
        SPAI: ClassVar[str] = ...
        SVD: ClassVar[str] = ...
        SYSPFMG: ClassVar[str] = ...
        TELESCOPE: ClassVar[str] = ...
        TFS: ClassVar[str] = ...
        VPBJACOBI: ClassVar[str] = ...
    
    @classmethod
    def __init__(cls) -> Any: ...
    def addCompositePCType(self, pc_type: Type | str) -> None: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def apply(self, x: Vec, y: Vec) -> None: ...
    def applySymmetricLeft(self, x: Vec, y: Vec) -> None: ...
    def applySymmetricRight(self, x: Vec, y: Vec) -> None: ...
    def applyTranspose(self, x: Vec, y: Vec) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createPython(self, context: Any = ..., comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def getASMSubKSP(self) -> list[KSP]: ...
    def getBJacobiSubKSP(self) -> list[KSP]: ...
    def getCompositePC(self, n: int) -> None: ...
    def getDM(self) -> DM: ...
    def getDeflationCoarseKSP(self) -> KSP: ...
    def getDeflationPC(self) -> PC: ...
    def getFactorMatrix(self) -> Mat: ...
    def getFactorSolverType(self) -> str: ...
    def getFailedReason(self) -> FailedReason: ...
    def getFieldSplitSchurGetSubKSP(self) -> list[KSP]: ...
    def getFieldSplitSubIS(self, splitname: str) -> IS: ...
    def getFieldSplitSubKSP(self) -> list[KSP]: ...
    def getHPDDMCoarseCorrectionType(self) -> HPDDMCoarseCorrectionType: ...
    def getHPDDMComplexities(self) -> tuple[float, float]: ...
    def getHPDDMSTShareSubKSP(self) -> bool: ...
    def getHYPREType(self) -> str: ...
    def getKSP(self) -> KSP: ...
    def getMGCoarseSolve(self) -> KSP: ...
    def getMGInterpolation(self, level: int) -> Mat: ...
    def getMGLevels(self) -> int: ...
    def getMGRScale(self, level: int) -> Vec: ...
    def getMGRestriction(self, level: int) -> Mat: ...
    def getMGSmoother(self, level: int) -> KSP: ...
    def getMGSmootherDown(self, level: int) -> KSP: ...
    def getMGSmootherUp(self, level: int) -> KSP: ...
    def getMGType(self) -> MGType: ...
    def getOperators(self) -> tuple[Mat, Mat]: ...
    def getOptionsPrefix(self) -> str: ...
    def getPatchSubKSP(self) -> list[KSP]: ...
    def getPythonContext(self) -> Any: ...
    def getPythonType(self) -> str: ...
    def getType(self) -> str: ...
    def getUseAmat(self) -> bool: ...
    def matApply(self, x: Mat, y: Mat) -> None: ...
    def reset(self) -> None: ...
    def setASMLocalSubdomains(self, nsd: int, is_sub: Sequence[IS] | None = ..., is_local: Sequence[IS] | None = ...) -> None: ...
    def setASMOverlap(self, overlap: int) -> None: ...
    def setASMSortIndices(self, dosort: bool) -> None: ...
    def setASMTotalSubdomains(self, nsd: int, is_sub: Sequence[IS] | None = ..., is_local: Sequence[IS] | None = ...) -> None: ...
    def setASMType(self, asmtype: ASMType) -> None: ...
    def setBDDCChangeOfBasisMat(self, T: Mat, interior: bool = ...) -> None: ...
    def setBDDCCoarseningRatio(self, cratio: int) -> None: ...
    def setBDDCDirichletBoundaries(self, bndr: IS) -> None: ...
    def setBDDCDirichletBoundariesLocal(self, bndr: IS) -> None: ...
    def setBDDCDiscreteGradient(self, G: Mat, order: int = ..., field: int = ..., gord: bool = ..., conforming: bool = ...) -> None: ...
    def setBDDCDivergenceMat(self, div: Mat, trans: bool = ..., l2l: IS | None = ...) -> None: ...
    def setBDDCDofsSplitting(self, isfields: IS | Sequence[IS]) -> None: ...
    def setBDDCDofsSplittingLocal(self, isfields: IS | Sequence[IS]) -> None: ...
    def setBDDCLevels(self, levels: int) -> None: ...
    def setBDDCLocalAdjacency(self, csr: CSRIndicesSpec) -> None: ...
    def setBDDCNeumannBoundaries(self, bndr: IS) -> None: ...
    def setBDDCNeumannBoundariesLocal(self, bndr: IS) -> None: ...
    def setBDDCPrimalVerticesIS(self, primv: IS) -> None: ...
    def setBDDCPrimalVerticesLocalIS(self, primv: IS) -> None: ...
    def setCompositeType(self, ctype: CompositeType) -> None: ...
    def setCoordinates(self, coordinates: Sequence[Sequence[float]]) -> None: ...
    def setDM(self, dm: DM) -> None: ...
    def setDeflationCoarseMat(self, mat: Mat) -> None: ...
    def setDeflationCorrectionFactor(self, fact: float) -> None: ...
    def setDeflationInitOnly(self, flg: bool) -> None: ...
    def setDeflationLevels(self, levels: int) -> None: ...
    def setDeflationProjectionNullSpaceMat(self, mat: Mat) -> None: ...
    def setDeflationReductionFactor(self, red: int) -> None: ...
    def setDeflationSpace(self, W: Mat, transpose: bool) -> None: ...
    def setDeflationSpaceToCompute(self, space_type: DeflationSpaceType, size: int) -> None: ...
    def setFactorLevels(self, levels: int) -> None: ...
    def setFactorOrdering(self, ord_type: str | None = ..., nzdiag: float | None = ..., reuse: bool | None = ...) -> None: ...
    def setFactorPivot(self, zeropivot: float | None = ..., inblocks: bool | None = ...) -> None: ...
    def setFactorSetUpSolverType(self) -> None: ...
    def setFactorShift(self, shift_type: Mat.FactorShiftType | None = ..., amount: float | None = ...) -> None: ...
    def setFactorSolverType(self, solver: Mat.SolverType | str) -> None: ...
    def setFailedReason(self, reason: FailedReason | str) -> None: ...
    def setFieldSplitFields(self, bsize: int, *fields: tuple[str, Sequence[int]]) -> None: ...
    def setFieldSplitIS(self, *fields: tuple[str, IS]) -> None: ...
    def setFieldSplitSchurFactType(self, ctype: FieldSplitSchurFactType) -> None: ...
    def setFieldSplitSchurPreType(self, ptype: FieldSplitSchurPreType, pre: Mat | None = ...) -> None: ...
    def setFieldSplitType(self, ctype: CompositeType) -> None: ...
    def setFromOptions(self) -> None: ...
    def setGAMGLevels(self, levels: int) -> None: ...
    def setGAMGSmooths(self, smooths: int) -> None: ...
    def setGAMGType(self, gamgtype: GAMGType | str) -> None: ...
    def setGASMOverlap(self, overlap: int) -> None: ...
    def setGASMType(self, gasmtype: GASMType) -> None: ...
    def setHPDDMAuxiliaryMat(self, uis: IS, uaux: Mat) -> None: ...
    def setHPDDMCoarseCorrectionType(self, correction_type: HPDDMCoarseCorrectionType) -> None: ...
    def setHPDDMDeflationMat(self, uis: IS, U: Mat) -> None: ...
    def setHPDDMHasNeumannMat(self, has: bool) -> None: ...
    def setHPDDMRHSMat(self, B: Mat) -> None: ...
    def setHYPREAMSSetInteriorNodes(self, interior: Vec) -> None: ...
    def setHYPREDiscreteCurl(self, mat: Mat) -> None: ...
    def setHYPREDiscreteGradient(self, mat: Mat) -> None: ...
    def setHYPRESetAlphaPoissonMatrix(self, mat: Mat) -> None: ...
    def setHYPRESetBetaPoissonMatrix(self, mat: Mat | None = ...) -> None: ...
    def setHYPRESetEdgeConstantVectors(self, ozz: Vec, zoz: Vec, zzo: Vec | None = ...) -> None: ...
    def setHYPRESetInterpolations(self, dim: int, RT_Pi_Full: Mat | None = ..., RT_Pi=..., ND_Pi_Full: Mat | None = ..., ND_Pi=...) -> None: ...
    def setHYPREType(self, hypretype: str) -> None: ...
    def setMGCycleType(self, cycle_type: MGCycleType) -> None: ...
    def setMGCycleTypeOnLevel(self, level: int, cycle_type: MGCycleType) -> None: ...
    def setMGInterpolation(self, level, mat: Mat) -> None: ...
    def setMGLevels(self, levels: int) -> None: ...
    def setMGR(self, level: int, r: Vec) -> None: ...
    def setMGRScale(self, level: int, rscale: Vec) -> None: ...
    def setMGRestriction(self, level: int, mat: Mat) -> None: ...
    def setMGRhs(self, level: int, rhs: Vec) -> None: ...
    def setMGType(self, mgtype: MGType) -> None: ...
    def setMGX(self, level: int, x: Vec) -> None: ...
    def setOperators(self, A: Mat | None = ..., P: Mat | None = ...) -> None: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def setPatchCellNumbering(self, sec: Section) -> None: ...
    def setPatchComputeFunction(self, function, args=..., kargs=...) -> None: ...
    def setPatchComputeFunctionInteriorFacets(self, function, args=..., kargs=...) -> None: ...
    def setPatchComputeOperator(self, operator, args=..., kargs=...) -> None: ...
    def setPatchComputeOperatorInteriorFacets(self, operator, args=..., kargs=...) -> None: ...
    def setPatchConstructType(self, typ, operator=..., args=..., kargs=...) -> None: ...
    def setPatchDiscretisationInfo(self, dms, bs, cellNodeMaps, subspaceOffsets, ghostBcNodes, globalBcNodes) -> None: ...
    def setPythonContext(self, context: Any) -> None: ...
    def setPythonType(self, py_type: str) -> None: ...
    def setReusePreconditioner(self, flag: bool) -> None: ...
    def setSPAIBlockSize(self, n: int) -> None: ...
    def setSPAICacheSize(self, size: int) -> None: ...
    def setSPAIEpsilon(self, val: float) -> None: ...
    def setSPAIMax(self, maxval: int) -> None: ...
    def setSPAIMaxNew(self, maxval: int) -> None: ...
    def setSPAINBSteps(self, nbsteps: int) -> None: ...
    def setSPAISp(self, sym: int) -> None: ...
    def setSPAIVerbose(self, level: int) -> None: ...
    def setType(self, pc_type: Type | str) -> None: ...
    def setUp(self) -> None: ...
    def setUpOnBlocks(self) -> None: ...
    def setUseAmat(self, flag: bool) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...
    def __call__(self, *args, **kwargs): ...

class Partitioner(Object):
    class Type:
        CHACO: ClassVar[str] = ...
        GATHER: ClassVar[str] = ...
        MATPARTITIONING: ClassVar[str] = ...
        PARMETIS: ClassVar[str] = ...
        PTSCOTCH: ClassVar[str] = ...
        SHELL: ClassVar[str] = ...
        SIMPLE: ClassVar[str] = ...
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def getType(self) -> Type: ...
    def reset(self) -> None: ...
    def setFromOptions(self) -> None: ...
    def setShellPartition(self, numProcs: int, sizes: Sequence[int] | None = ..., points: Sequence[int] | None = ...) -> None: ...
    def setType(self, part_type: Type | str) -> None: ...
    def setUp(self) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class Quad(Object):
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def duplicate(self) -> Quad: ...
    def getData(self, *args, **kwargs): ...
    def getNumComponents(self) -> int: ...
    def getOrder(self) -> int: ...
    def setNumComponents(self, nc: int) -> None: ...
    def setOrder(self, order: int) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class Random(Object):
    class Type:
        RAND: ClassVar[str] = ...
        RAND48: ClassVar[str] = ...
        RANDER48: ClassVar[str] = ...
        RANDOM123: ClassVar[str] = ...
        SPRNG: ClassVar[str] = ...
    
    interval: Random.interval
    seed: Random.seed
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def getInterval(self) -> tuple[Scalar, Scalar]: ...
    def getSeed(self) -> int: ...
    def getType(self) -> str: ...
    def getValue(self) -> Scalar: ...
    def getValueReal(self) -> float: ...
    def setFromOptions(self) -> None: ...
    def setInterval(self, interval: tuple[Scalar, Scalar]) -> None: ...
    def setSeed(self, seed: int | None = ...) -> None: ...
    def setType(self, rnd_type: Random.Type | str) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...
    def __call__(self, *args, **kwargs): ...

class SF(Object):
    class Type:
        ALLGATHER: ClassVar[str] = ...
        ALLGATHERV: ClassVar[str] = ...
        ALLTOALL: ClassVar[str] = ...
        BASIC: ClassVar[str] = ...
        GATHER: ClassVar[str] = ...
        GATHERV: ClassVar[str] = ...
        NEIGHBOR: ClassVar[str] = ...
        WINDOW: ClassVar[str] = ...
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def bcastBegin(self, unit: Datatype, rootdata: ndarray, leafdata: ndarray, op: Op) -> None: ...
    def bcastEnd(self, unit: Datatype, rootdata: ndarray, leafdata: ndarray, op: Op) -> None: ...
    def compose(self, sf: SF) -> SF: ...
    def computeDegree(self) -> ArrayInt: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createEmbeddedLeafSF(self, selected: Sequence[int]) -> SF: ...
    def createEmbeddedRootSF(self, selected: Sequence[int]) -> SF: ...
    def createInverse(self) -> SF: ...
    def createSectionSF(self, rootSection: Section, remoteOffsets: Sequence[int] | None, leafSection: Section) -> SF: ...
    def destroy(self) -> Self: ...
    def distributeSection(self, rootSection: Section, leafSection: Section | None = ...) -> tuple[ArrayInt, Section]: ...
    def fetchAndOpBegin(self, unit: Datatype, rootdata: ndarray, leafdata: ndarray, leafupdate: ndarray, op: Op) -> None: ...
    def fetchAndOpEnd(self, unit: Datatype, rootdata: ndarray, leafdata: ndarray, leafupdate: ndarray, op: Op) -> None: ...
    def gatherBegin(self, unit: Datatype, leafdata: ndarray, multirootdata: ndarray) -> None: ...
    def gatherEnd(self, unit: Datatype, leafdata: ndarray, multirootdata: ndarray) -> None: ...
    def getGraph(self) -> tuple[int, ArrayInt, ArrayInt]: ...
    def getMulti(self) -> SF: ...
    def getType(self) -> str: ...
    def reduceBegin(self, unit: Datatype, leafdata: ndarray, rootdata: ndarray, op: Op) -> None: ...
    def reduceEnd(self, unit: Datatype, leafdata: ndarray, rootdata: ndarray, op: Op) -> None: ...
    def reset(self) -> None: ...
    def scatterBegin(self, unit: Datatype, multirootdata: ndarray, leafdata: ndarray) -> None: ...
    def scatterEnd(self, unit: Datatype, multirootdata: ndarray, leafdata: ndarray) -> None: ...
    def setFromOptions(self) -> None: ...
    def setGraph(self, nroots: int, local: Sequence[int], remote: Sequence[int]) -> None: ...
    def setRankOrder(self, flag: bool) -> None: ...
    def setType(self, sf_type: Type | str) -> None: ...
    def setUp(self) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class SNES(Object):
    class ConvergedReason:
        CONVERGED_FNORM_ABS: ClassVar[int] = ...
        CONVERGED_FNORM_RELATIVE: ClassVar[int] = ...
        CONVERGED_ITERATING: ClassVar[int] = ...
        CONVERGED_ITS: ClassVar[int] = ...
        CONVERGED_SNORM_RELATIVE: ClassVar[int] = ...
        DIVERGED_DTOL: ClassVar[int] = ...
        DIVERGED_FNORM_NAN: ClassVar[int] = ...
        DIVERGED_FUNCTION_COUNT: ClassVar[int] = ...
        DIVERGED_FUNCTION_DOMAIN: ClassVar[int] = ...
        DIVERGED_INNER: ClassVar[int] = ...
        DIVERGED_JACOBIAN_DOMAIN: ClassVar[int] = ...
        DIVERGED_LINEAR_SOLVE: ClassVar[int] = ...
        DIVERGED_LINE_SEARCH: ClassVar[int] = ...
        DIVERGED_LOCAL_MIN: ClassVar[int] = ...
        DIVERGED_MAX_IT: ClassVar[int] = ...
        DIVERGED_TR_DELTA: ClassVar[int] = ...
        ITERATING: ClassVar[int] = ...

    class NewtonALCorrectionType:
        EXACT: ClassVar[int] = ...
        NORMAL: ClassVar[int] = ...

    class NormSchedule:
        ALWAYS: ClassVar[int] = ...
        DEFAULT: ClassVar[int] = ...
        FINAL_ONLY: ClassVar[int] = ...
        INITIAL_FINAL_ONLY: ClassVar[int] = ...
        INITIAL_ONLY: ClassVar[int] = ...
        NONE: ClassVar[int] = ...
        NORM_ALWAYS: ClassVar[int] = ...
        NORM_DEFAULT: ClassVar[int] = ...
        NORM_FINAL_ONLY: ClassVar[int] = ...
        NORM_INITIAL_FINAL_ONLY: ClassVar[int] = ...
        NORM_INITIAL_ONLY: ClassVar[int] = ...
        NORM_NONE: ClassVar[int] = ...

    class Type:
        ANDERSON: ClassVar[str] = ...
        ASPIN: ClassVar[str] = ...
        COMPOSITE: ClassVar[str] = ...
        FAS: ClassVar[str] = ...
        KSPONLY: ClassVar[str] = ...
        KSPTRANSPOSEONLY: ClassVar[str] = ...
        MS: ClassVar[str] = ...
        NASM: ClassVar[str] = ...
        NCG: ClassVar[str] = ...
        NEWTONAL: ClassVar[str] = ...
        NEWTONLS: ClassVar[str] = ...
        NEWTONTR: ClassVar[str] = ...
        NGMRES: ClassVar[str] = ...
        NGS: ClassVar[str] = ...
        NRICHARDSON: ClassVar[str] = ...
        PATCH: ClassVar[str] = ...
        PYTHON: ClassVar[str] = ...
        QN: ClassVar[str] = ...
        SHELL: ClassVar[str] = ...
        VINEWTONRSLS: ClassVar[str] = ...
        VINEWTONSSLS: ClassVar[str] = ...
    
    appctx: SNES.appctx
    atol: SNES.atol
    dm: SNES.dm
    history: SNES.history
    is_converged: SNES.is_converged
    is_diverged: SNES.is_diverged
    is_iterating: SNES.is_iterating
    its: SNES.its
    ksp: SNES.ksp
    linesearch: SNES.linesearch
    max_funcs: SNES.max_funcs
    max_it: SNES.max_it
    norm: SNES.norm
    npc: SNES.npc
    reason: SNES.reason
    rtol: SNES.rtol
    stol: SNES.stol
    use_ew: SNES.use_ew
    use_fd: SNES.use_fd
    use_ksp: SNES.use_ksp
    use_mf: SNES.use_mf
    vec_rhs: SNES.vec_rhs
    vec_sol: SNES.vec_sol
    vec_upd: SNES.vec_upd
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def callConvergenceTest(self, its: int, xnorm: float, ynorm: float, fnorm: float) -> ConvergedReason: ...
    def cancelMonitor(self, *args, **kwargs): ...
    def computeFunction(self, x: Vec, f: Vec) -> None: ...
    def computeJacobian(self, x: Vec, J: Mat, P: Mat | None = ...) -> None: ...
    def computeNGS(self, x: Vec, b: Vec | None = ...) -> None: ...
    def computeObjective(self, x: Vec) -> float: ...
    def converged(self, its: int, xnorm: float, ynorm: float, fnorm: float) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createPython(self, context: Any = ..., comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def getAppCtx(self, *args, **kwargs): ...
    def getApplicationContext(self) -> Any: ...
    def getCompositeNumber(self) -> int: ...
    def getCompositeSNES(self, n: int) -> SNES: ...
    def getConvergedReason(self) -> ConvergedReason: ...
    def getConvergenceHistory(self) -> tuple[ArrayReal, ArrayInt]: ...
    def getConvergenceTest(self) -> SNESConvergedFunction: ...
    def getDM(self) -> DM: ...
    def getDivergenceTolerance(self) -> float: ...
    def getErrorIfNotConverged(self) -> bool: ...
    def getFASCoarseSolve(self) -> SNES: ...
    def getFASCycleSNES(self, level: int) -> SNES: ...
    def getFASInjection(self, level: int) -> Mat: ...
    def getFASInterpolation(self, level: int) -> Mat: ...
    def getFASLevels(self) -> int: ...
    def getFASRestriction(self, level: int) -> Mat: ...
    def getFASSmoother(self, level: int) -> SNES: ...
    def getFASSmootherDown(self, level: int) -> SNES: ...
    def getFASSmootherUp(self, level: int) -> SNES: ...
    def getFunction(self) -> SNESFunction: ...
    def getFunctionEvaluations(self) -> int: ...
    def getFunctionNorm(self) -> float: ...
    def getInitialGuess(self) -> SNESGuessFunction: ...
    def getIterationNumber(self) -> int: ...
    def getJacobian(self) -> tuple[Mat, Mat, SNESJacobianFunction]: ...
    def getKSP(self) -> KSP: ...
    def getKSPFailures(self) -> int: ...
    def getLineSearch(self) -> SNESLineSearch: ...
    def getLinearSolveFailures(self, *args, **kwargs): ...
    def getLinearSolveIterations(self) -> int: ...
    def getMaxFunctionEvaluations(self) -> int: ...
    def getMaxKSPFailures(self) -> int: ...
    def getMaxLinearSolveFailures(self, *args, **kwargs): ...
    def getMaxNonlinearStepFailures(self, *args, **kwargs): ...
    def getMaxStepFailures(self) -> int: ...
    def getMonitor(self) -> list[tuple[SNESMonitorFunction, tuple[Any, ...], dict[str, Any]]]: ...
    def getNASMNumber(self) -> int: ...
    def getNASMSNES(self, n: int) -> SNES: ...
    def getNGS(self) -> SNESNGSFunction: ...
    def getNPC(self) -> SNES: ...
    def getNPCSide(self) -> PC.Side: ...
    def getNewtonALLoadParameter(self) -> float: ...
    def getNonlinearStepFailures(self, *args, **kwargs): ...
    def getNormSchedule(self) -> NormSchedule: ...
    def getObjective(self) -> SNESObjFunction: ...
    def getOptionsPrefix(self) -> str: ...
    def getParamsEW(self) -> dict[str, int | float]: ...
    def getPythonContext(self) -> Any: ...
    def getPythonType(self) -> str: ...
    def getRhs(self) -> Vec: ...
    def getSolution(self) -> Vec: ...
    def getSolutionUpdate(self) -> Vec: ...
    def getStepFailures(self) -> int: ...
    def getTRTolerances(self) -> tuple[float, float, float]: ...
    def getTRUpdateParameters(self) -> tuple[float, float, float, float, float]: ...
    def getTolerances(self) -> tuple[float, float, float, int]: ...
    def getType(self) -> str: ...
    def getUpdate(self) -> SNESUpdateFunction: ...
    def getUseEW(self) -> bool: ...
    def getUseFD(self, *args, **kwargs): ...
    def getUseKSP(self) -> bool: ...
    def getUseMF(self) -> bool: ...
    def getVIInactiveSet(self) -> IS: ...
    def hasNPC(self) -> bool: ...
    def logConvergenceHistory(self, norm: float, linear_its: int = ...) -> None: ...
    def monitor(self, its, rnorm) -> None: ...
    def monitorCancel(self) -> None: ...
    def reset(self) -> None: ...
    def setAppCtx(self, *args, **kwargs): ...
    def setApplicationContext(self, appctx: Any) -> None: ...
    def setConvergedReason(self, reason: ConvergedReason) -> None: ...
    def setConvergenceHistory(self, length=..., reset=...) -> None: ...
    def setConvergenceTest(self, converged: SNESConvergedFunction | Literal['skip', 'default'], args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setDM(self, dm: DM) -> None: ...
    def setDivergenceTolerance(self, dtol: float) -> None: ...
    def setErrorIfNotConverged(self, flag: bool) -> None: ...
    def setFASInjection(self, level: int, mat: Mat) -> None: ...
    def setFASInterpolation(self, level: int, mat: Mat) -> None: ...
    def setFASLevels(self, levels: int, comms: Sequence[Comm] = ...) -> None: ...
    def setFASRScale(self, level: int, vec: Vec) -> None: ...
    def setFASRestriction(self, level: int, mat: Mat) -> None: ...
    def setForceIteration(self, force: bool) -> None: ...
    def setFromOptions(self) -> None: ...
    def setFunction(self, function: SNESFunction | None, f: Vec | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setFunctionNorm(self, norm: float) -> None: ...
    def setInitialGuess(self, initialguess: SNESGuessFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setIterationNumber(self, its: int) -> None: ...
    def setJacobian(self, jacobian: SNESJacobianFunction | None, J: Mat | None = ..., P: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setKSP(self, ksp: KSP) -> None: ...
    def setLineSearch(self, linesearch: SNESLineSearch) -> None: ...
    def setLineSearchPreCheck(self, precheck: SNESLSPreFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setMaxFunctionEvaluations(self, max_funcs: int) -> None: ...
    def setMaxKSPFailures(self, max_fails: int) -> None: ...
    def setMaxLinearSolveFailures(self, *args, **kwargs): ...
    def setMaxNonlinearStepFailures(self, *args, **kwargs): ...
    def setMaxStepFailures(self, max_fails: int) -> None: ...
    def setMonitor(self, monitor: SNESMonitorFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setNGS(self, ngs: SNESNGSFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setNPC(self, snes: SNES) -> None: ...
    def setNPCSide(self, side: PC.Side) -> None: ...
    def setNewtonALCorrectionType(self, corrtype: NewtonALCorrectionType) -> None: ...
    def setNewtonALFunction(self, function: SNESFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setNormSchedule(self, normsched: NormSchedule) -> None: ...
    def setObjective(self, objective: SNESObjFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def setParamsEW(self, version: int = ..., rtol_0: float = ..., rtol_max: float = ..., gamma: float = ..., alpha: float = ..., alpha2: float = ..., threshold: float = ...) -> None: ...
    def setPatchCellNumbering(self, sec: Section) -> None: ...
    def setPatchComputeFunction(self, function, args=..., kargs=...) -> None: ...
    def setPatchComputeOperator(self, operator, args=..., kargs=...) -> None: ...
    def setPatchConstructType(self, typ, operator=..., args=..., kargs=...) -> None: ...
    def setPatchDiscretisationInfo(self, dms, bs, cellNodeMaps, subspaceOffsets, ghostBcNodes, globalBcNodes) -> None: ...
    def setPythonContext(self, context: Any) -> None: ...
    def setPythonType(self, py_type: str) -> None: ...
    def setResetCounters(self, reset: bool = ...) -> None: ...
    def setSolution(self, vec: Vec) -> None: ...
    def setTRTolerances(self, delta_min: float = ..., delta_max: float = ..., delta_0: float = ...) -> None: ...
    def setTRUpdateParameters(self, eta1: float = ..., eta2: float = ..., eta3: float = ..., t1: float = ..., t2: float = ...) -> None: ...
    def setTolerances(self, rtol: float = ..., atol: float = ..., stol: float = ..., max_it: int = ...) -> None: ...
    def setType(self, snes_type: Type | str) -> None: ...
    def setUp(self) -> None: ...
    def setUpMatrices(self) -> None: ...
    def setUpdate(self, update: SNESUpdateFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setUseEW(self, flag: bool = ..., *targs: Any, **kargs: Any) -> None: ...
    def setUseFD(self, flag=...) -> None: ...
    def setUseKSP(self, flag=...) -> None: ...
    def setUseMF(self, flag=...) -> None: ...
    def setVariableBounds(self, xl: Vec, xu: Vec) -> None: ...
    def solve(self, b: Vec | None = ..., x: Vec | None = ...) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class SNESLineSearch(Object):
    class Type:
        BASIC: ClassVar[str] = ...
        BISECTION: ClassVar[str] = ...
        BT: ClassVar[str] = ...
        CP: ClassVar[str] = ...
        L2: ClassVar[str] = ...
        NCGLINEAR: ClassVar[str] = ...
        NLEQERR: ClassVar[str] = ...
        NONE: ClassVar[str] = ...
        SHELL: ClassVar[str] = ...
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> None: ...
    def getOrder(self) -> int: ...
    def getTolerances(self) -> tuple[float, float, float, float, float, int]: ...
    def getType(self) -> str: ...
    def setFromOptions(self) -> None: ...
    def setOrder(self, order: int) -> None: ...
    def setTolerances(self, minstep: float = ..., maxstep: float = ..., rtol: float = ..., atol: float = ..., ltol: float = ..., max_its: int = ...) -> None: ...
    def setType(self, ls_type: Type | str) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class Scatter(Object):
    class Mode:
        FORWARD: ClassVar[int] = ...
        FORWARD_LOCAL: ClassVar[int] = ...
        REVERSE: ClassVar[int] = ...
        REVERSE_LOCAL: ClassVar[int] = ...
        SCATTER_FORWARD: ClassVar[int] = ...
        SCATTER_FORWARD_LOCAL: ClassVar[int] = ...
        SCATTER_REVERSE: ClassVar[int] = ...
        SCATTER_REVERSE_LOCAL: ClassVar[int] = ...

    class Type:
        ALLGATHER: ClassVar[str] = ...
        ALLGATHERV: ClassVar[str] = ...
        ALLTOALL: ClassVar[str] = ...
        BASIC: ClassVar[str] = ...
        GATHER: ClassVar[str] = ...
        GATHERV: ClassVar[str] = ...
        NEIGHBOR: ClassVar[str] = ...
        WINDOW: ClassVar[str] = ...
    toAll: ClassVar[method] = ...
    toZero: ClassVar[method] = ...
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def begin(self, vec_from: Vec, vec_to: Vec, addv: InsertModeSpec = ..., mode: ScatterModeSpec = ...) -> None: ...
    def copy(self) -> Scatter: ...
    @overload
    def create(self, vec_from: Vec, is_from: IS, vec_to: Vec, is_to: IS) -> Self: ...
    @overload
    def create(self, v1, is1, v2, _None) -> Any: ...
    def destroy(self) -> Self: ...
    def end(self, vec_from: Vec, vec_to: Vec, addv: InsertModeSpec = ..., mode: ScatterModeSpec = ...) -> None: ...
    def getType(self) -> str: ...
    def scatter(self, vec_from: Vec, vec_to: Vec, addv: InsertModeSpec = ..., mode: ScatterModeSpec = ...) -> None: ...
    def scatterBegin(self, *args, **kwargs): ...
    def scatterEnd(self, *args, **kwargs): ...
    def setFromOptions(self) -> None: ...
    def setType(self, scatter_type: Type | str) -> None: ...
    def setUp(self) -> Self: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...
    def __call__(self, *args, **kwargs): ...

class ScatterMode:
    FORWARD: ClassVar[int] = ...
    FORWARD_LOCAL: ClassVar[int] = ...
    REVERSE: ClassVar[int] = ...
    REVERSE_LOCAL: ClassVar[int] = ...
    SCATTER_FORWARD: ClassVar[int] = ...
    SCATTER_FORWARD_LOCAL: ClassVar[int] = ...
    SCATTER_REVERSE: ClassVar[int] = ...
    SCATTER_REVERSE_LOCAL: ClassVar[int] = ...

class Section(Object):
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def addConstraintDof(self, point: int, numDof: int) -> None: ...
    def addDof(self, point: int, numDof: int) -> None: ...
    def addFieldConstraintDof(self, point: int, field: int, numDof: int) -> None: ...
    def addFieldDof(self, point: int, field: int, numDof: int) -> None: ...
    def clone(self) -> Section: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createGlobalSection(self, sf: SF) -> Section: ...
    def destroy(self) -> Self: ...
    def getChart(self) -> tuple[int, int]: ...
    def getConstrainedStorageSize(self) -> int: ...
    def getConstraintDof(self, point: int) -> int: ...
    def getConstraintIndices(self, point: int) -> ArrayInt: ...
    def getDof(self, point: int) -> int: ...
    def getFieldComponents(self, field: int) -> int: ...
    def getFieldConstraintDof(self, point: int, field: int) -> int: ...
    def getFieldConstraintIndices(self, point: int, field: int) -> ArrayInt: ...
    def getFieldDof(self, point: int, field: int) -> int: ...
    def getFieldName(self, field: int) -> str: ...
    def getFieldOffset(self, point: int, field: int) -> int: ...
    def getMaxDof(self) -> int: ...
    def getNumFields(self) -> int: ...
    def getOffset(self, point: int) -> int: ...
    def getOffsetRange(self) -> tuple[int, int]: ...
    def getPermutation(self) -> IS: ...
    def getStorageSize(self) -> int: ...
    def reset(self) -> None: ...
    def setChart(self, pStart: int, pEnd: int) -> None: ...
    def setConstraintDof(self, point: int, numDof: int) -> None: ...
    def setConstraintIndices(self, point: int, indices: Sequence[int]) -> None: ...
    def setDof(self, point: int, numDof: int) -> None: ...
    def setFieldComponents(self, field: int, numComp: int) -> None: ...
    def setFieldConstraintDof(self, point: int, field: int, numDof: int) -> None: ...
    def setFieldConstraintIndices(self, point: int, field: int, indices: Sequence[int]) -> None: ...
    def setFieldDof(self, point: int, field: int, numDof: int) -> None: ...
    def setFieldName(self, field: int, fieldName: str) -> None: ...
    def setFieldOffset(self, point: int, field: int, offset: int) -> None: ...
    def setNumFields(self, numFields: int) -> None: ...
    def setOffset(self, point: int, offset: int) -> None: ...
    def setPermutation(self, perm: IS) -> None: ...
    def setUp(self) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class Space(Object):
    class Type:
        POINT: ClassVar[str] = ...
        POLYNOMIAL: ClassVar[str] = ...
        PTRIMMED: ClassVar[str] = ...
        SUBSPACE: ClassVar[str] = ...
        SUM: ClassVar[str] = ...
        TENSOR: ClassVar[str] = ...
        WXY: ClassVar[str] = ...
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def getDegree(self) -> tuple[int, int]: ...
    def getDimension(self) -> int: ...
    def getNumComponents(self) -> int: ...
    def getNumVariables(self) -> int: ...
    def getPTrimmedFormDegree(self) -> int: ...
    def getPointPoints(self) -> Quad: ...
    def getPolynomialTensor(self) -> bool: ...
    def getSumConcatenate(self) -> bool: ...
    def getSumNumSubspaces(self) -> int: ...
    def getSumSubspace(self, s: int) -> Space: ...
    def getTensorNumSubspaces(self) -> int: ...
    def getTensorSubspace(self, s: int) -> Space: ...
    def getType(self) -> str: ...
    def setDegree(self, degree: int | None, maxDegree: int | None) -> None: ...
    def setFromOptions(self) -> None: ...
    def setNumComponents(self, nc: int) -> None: ...
    def setNumVariables(self, n: int) -> None: ...
    def setPTrimmedFormDegree(self, formDegree: int) -> None: ...
    def setPointPoints(self, quad: Quad) -> None: ...
    def setPolynomialTensor(self, tensor: bool) -> None: ...
    def setSumConcatenate(self, concatenate: bool) -> None: ...
    def setSumNumSubspaces(self, numSumSpaces: int) -> None: ...
    def setSumSubspace(self, s: int, subsp: Space) -> None: ...
    def setTensorNumSubspaces(self, numTensSpaces: int) -> None: ...
    def setTensorSubspace(self, s: int, subsp: Space) -> None: ...
    def setType(self, space_type: Type | str) -> Self: ...
    def setUp(self) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class Sys:
    Print: ClassVar[method] = ...
    getDefaultComm: ClassVar[method] = ...
    getVersion: ClassVar[method] = ...
    getVersionInfo: ClassVar[method] = ...
    hasExternalPackage: ClassVar[method] = ...
    infoAllow: ClassVar[method] = ...
    isFinalized: ClassVar[method] = ...
    isInitialized: ClassVar[method] = ...
    popErrorHandler: ClassVar[method] = ...
    popSignalHandler: ClassVar[method] = ...
    pushErrorHandler: ClassVar[method] = ...
    registerCitation: ClassVar[method] = ...
    setDefaultComm: ClassVar[method] = ...
    sleep: ClassVar[method] = ...
    splitOwnership: ClassVar[method] = ...
    syncFlush: ClassVar[method] = ...
    syncPrint: ClassVar[method] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...

class TAO(Object):
    class ALMMType:
        CLASSIC: ClassVar[int] = ...
        PHR: ClassVar[int] = ...

    class BNCGType:
        DK: ClassVar[int] = ...
        DY: ClassVar[int] = ...
        FR: ClassVar[int] = ...
        GD: ClassVar[int] = ...
        HS: ClassVar[int] = ...
        HZ: ClassVar[int] = ...
        KD: ClassVar[int] = ...
        PCGD: ClassVar[int] = ...
        PRP: ClassVar[int] = ...
        PRP_PLUS: ClassVar[int] = ...
        SSML_BFGS: ClassVar[int] = ...
        SSML_BRDN: ClassVar[int] = ...
        SSML_DFP: ClassVar[int] = ...

    class ConvergedReason:
        CONTINUE_ITERATING: ClassVar[int] = ...
        CONVERGED_GATOL: ClassVar[int] = ...
        CONVERGED_GRTOL: ClassVar[int] = ...
        CONVERGED_GTTOL: ClassVar[int] = ...
        CONVERGED_ITERATING: ClassVar[int] = ...
        CONVERGED_MINF: ClassVar[int] = ...
        CONVERGED_STEPTOL: ClassVar[int] = ...
        CONVERGED_USER: ClassVar[int] = ...
        DIVERGED_LS_FAILURE: ClassVar[int] = ...
        DIVERGED_MAXFCN: ClassVar[int] = ...
        DIVERGED_MAXITS: ClassVar[int] = ...
        DIVERGED_NAN: ClassVar[int] = ...
        DIVERGED_TR_REDUCTION: ClassVar[int] = ...
        DIVERGED_USER: ClassVar[int] = ...
        ITERATING: ClassVar[int] = ...

    class Reason:
        CONTINUE_ITERATING: ClassVar[int] = ...
        CONVERGED_GATOL: ClassVar[int] = ...
        CONVERGED_GRTOL: ClassVar[int] = ...
        CONVERGED_GTTOL: ClassVar[int] = ...
        CONVERGED_ITERATING: ClassVar[int] = ...
        CONVERGED_MINF: ClassVar[int] = ...
        CONVERGED_STEPTOL: ClassVar[int] = ...
        CONVERGED_USER: ClassVar[int] = ...
        DIVERGED_LS_FAILURE: ClassVar[int] = ...
        DIVERGED_MAXFCN: ClassVar[int] = ...
        DIVERGED_MAXITS: ClassVar[int] = ...
        DIVERGED_NAN: ClassVar[int] = ...
        DIVERGED_TR_REDUCTION: ClassVar[int] = ...
        DIVERGED_USER: ClassVar[int] = ...
        ITERATING: ClassVar[int] = ...

    class Type:
        ADMM: ClassVar[str] = ...
        ALMM: ClassVar[str] = ...
        ASFLS: ClassVar[str] = ...
        ASILS: ClassVar[str] = ...
        BLMVM: ClassVar[str] = ...
        BMRM: ClassVar[str] = ...
        BNCG: ClassVar[str] = ...
        BNLS: ClassVar[str] = ...
        BNTL: ClassVar[str] = ...
        BNTR: ClassVar[str] = ...
        BQNKLS: ClassVar[str] = ...
        BQNKTL: ClassVar[str] = ...
        BQNKTR: ClassVar[str] = ...
        BQNLS: ClassVar[str] = ...
        BQPIP: ClassVar[str] = ...
        BRGN: ClassVar[str] = ...
        CG: ClassVar[str] = ...
        GPCG: ClassVar[str] = ...
        IPM: ClassVar[str] = ...
        LCL: ClassVar[str] = ...
        LMVM: ClassVar[str] = ...
        NLS: ClassVar[str] = ...
        NM: ClassVar[str] = ...
        NTL: ClassVar[str] = ...
        NTR: ClassVar[str] = ...
        OWLQN: ClassVar[str] = ...
        PDIPM: ClassVar[str] = ...
        POUNDERS: ClassVar[str] = ...
        PYTHON: ClassVar[str] = ...
        SHELL: ClassVar[str] = ...
        SSFLS: ClassVar[str] = ...
        SSILS: ClassVar[str] = ...
        TRON: ClassVar[str] = ...
    
    appctx: TAO.appctx
    cnorm: TAO.cnorm
    converged: TAO.converged
    ctol: TAO.ctol
    diverged: TAO.diverged
    ftol: TAO.ftol
    function: TAO.function
    gnorm: TAO.gnorm
    gradient: TAO.gradient
    gtol: TAO.gtol
    iterating: TAO.iterating
    its: TAO.its
    ksp: TAO.ksp
    objective: TAO.objective
    reason: TAO.reason
    solution: TAO.solution
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def cancelMonitor(self) -> None: ...
    def computeConstraints(self, x: Vec, c: Vec) -> None: ...
    def computeDualVariables(self, xl: Vec, xu: Vec) -> None: ...
    def computeGradient(self, x: Vec, g: Vec) -> None: ...
    def computeHessian(self, x: Vec, H: Mat, P: Mat | None = ...) -> None: ...
    def computeJacobian(self, x: Vec, J: Mat, P: Mat | None = ...) -> None: ...
    def computeObjective(self, x: Vec) -> float: ...
    def computeObjectiveGradient(self, x: Vec, g: Vec) -> float: ...
    def computeResidual(self, x: Vec, f: Vec) -> None: ...
    def computeVariableBounds(self, xl: Vec, xu: Vec) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createPython(self, context: Any = ..., comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def getALMMSubsolver(self) -> TAO: ...
    def getALMMType(self) -> ALMMType: ...
    def getAppCtx(self) -> Any: ...
    def getBNCGType(self) -> BNCGType: ...
    def getBRGNDampingVector(self) -> Vec: ...
    def getBRGNSubsolver(self) -> TAO: ...
    def getConstraintTolerances(self) -> tuple[float, float]: ...
    def getConvergedReason(self) -> ConvergedReason: ...
    def getConvergenceTest(self) -> tuple[TAOConvergedFunction, tuple[Any, ...], dict[str, Any]]: ...
    def getFunctionValue(self, *args, **kwargs): ...
    def getGradient(self) -> tuple[Vec, TAOGradientFunction]: ...
    def getGradientNorm(self) -> Mat: ...
    def getHessian(self) -> tuple[Mat, Mat, TAOHessianFunction]: ...
    def getIterationNumber(self) -> int: ...
    def getKSP(self) -> KSP: ...
    def getLMVMH0(self) -> Mat: ...
    def getLMVMH0KSP(self) -> KSP: ...
    def getLMVMMat(self) -> Mat: ...
    def getLineSearch(self) -> TAOLineSearch: ...
    def getMaximumFunctionEvaluations(self) -> int: ...
    def getMaximumIterations(self) -> int: ...
    def getMonitor(self) -> list[tuple[TAOMonitorFunction, tuple[Any, ...], dict[str, Any]]]: ...
    def getObjective(self) -> TAOObjectiveFunction: ...
    def getObjectiveAndGradient(self) -> tuple[Vec, TAOObjectiveGradientFunction]: ...
    def getObjectiveValue(self) -> float: ...
    def getOptionsPrefix(self) -> str: ...
    def getPythonContext(self) -> Any: ...
    def getPythonType(self) -> str: ...
    def getSolution(self) -> Vec: ...
    def getSolutionNorm(self) -> tuple[float, float, float]: ...
    def getSolutionStatus(self) -> tuple[int, float, float, float, float, ConvergedReason]: ...
    def getTolerances(self) -> tuple[float, float, float]: ...
    def getType(self) -> str: ...
    def getUpdate(self) -> tuple[TAOUpdateFunction, tuple[Any, ...], dict[str, Any]]: ...
    def getVariableBounds(self) -> tuple[Vec, Vec]: ...
    def monitor(self, its: int = ..., f: float = ..., res: float = ..., cnorm: float = ..., step: float = ...) -> None: ...
    def setALMMSubsolver(self, subsolver: TAO) -> None: ...
    def setALMMType(self, tao_almm_type: ALMMType) -> None: ...
    def setAppCtx(self, appctx: Any) -> None: ...
    def setBNCGType(self, cg_type: BNCGType) -> None: ...
    def setBRGNDictionaryMatrix(self, D: Mat) -> None: ...
    def setBRGNRegularizerHessian(self, hessian, H: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setBRGNRegularizerObjectiveGradient(self, objgrad, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setBRGNRegularizerWeight(self, weight: float) -> None: ...
    def setBRGNSmoothL1Epsilon(self, epsilon: float) -> None: ...
    def setConstraintTolerances(self, catol: float = ..., crtol: float = ...) -> None: ...
    def setConstraints(self, constraints: TAOConstraintsFunction, C: Vec | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setConvergedReason(self, reason: ConvergedReason) -> None: ...
    def setConvergenceTest(self, converged: TAOConvergedFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setEqualityConstraints(self, equality_constraints, c: Vec, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setFromOptions(self) -> None: ...
    def setGradient(self, gradient: TAOGradientFunction, g: Vec | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setGradientNorm(self, mat: Mat) -> None: ...
    def setHessian(self, hessian: TAOHessianFunction, H: Mat | None = ..., P: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setInequalityConstraints(self, inequality_constraints, c: Vec, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setInitial(self, *args, **kwargs): ...
    def setInitialTrustRegionRadius(self, radius: float) -> None: ...
    def setIterationNumber(self, its: int) -> None: ...
    def setJacobian(self, jacobian: TAOJacobianFunction, J: Mat | None = ..., P: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setJacobianDesign(self, jacobian_design, J: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setJacobianEquality(self, jacobian_equality, J: Mat | None = ..., P: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setJacobianInequality(self, jacobian_inequality, J: Mat | None = ..., P: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setJacobianResidual(self, jacobian: TAOJacobianResidualFunction, J: Mat | None = ..., P: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setJacobianState(self, jacobian_state, J: Mat | None = ..., P: Mat | None = ..., I: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setLMVMH0(self, mat: Mat) -> None: ...
    def setLMVMMat(self, M: Mat) -> None: ...
    def setMaximumFunctionEvaluations(self, mit: int) -> None: ...
    def setMaximumIterations(self, mit: int) -> float: ...
    def setMonitor(self, monitor: TAOMonitorFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setObjective(self, objective: TAOObjectiveFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setObjectiveGradient(self, objgrad: TAOObjectiveGradientFunction, g: Vec | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def setPythonContext(self, context: Any) -> None: ...
    def setPythonType(self, py_type: str) -> None: ...
    def setResidual(self, residual: TAOResidualFunction, R: Vec, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setSolution(self, x: Vec) -> None: ...
    def setStateDesignIS(self, state: IS | None = ..., design: IS | None = ...) -> None: ...
    def setTolerances(self, gatol: float = ..., grtol: float = ..., gttol: float = ...) -> None: ...
    def setType(self, tao_type: Type | str) -> None: ...
    def setUp(self) -> None: ...
    def setUpdate(self, update: TAOUpdateFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setVariableBounds(self, varbounds: tuple[Vec, Vec] | TAOVariableBoundsFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def solve(self, x: Vec | None = ...) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class TAOLineSearch(Object):
    class Reason:
        CONTINUE_SEARCH: ClassVar[int] = ...
        FAILED_ASCENT: ClassVar[int] = ...
        FAILED_BADPARAMETER: ClassVar[int] = ...
        FAILED_INFORNAN: ClassVar[int] = ...
        HALTED_LOWERBOUND: ClassVar[int] = ...
        HALTED_MAXFCN: ClassVar[int] = ...
        HALTED_OTHER: ClassVar[int] = ...
        HALTED_RTOL: ClassVar[int] = ...
        HALTED_UPPERBOUND: ClassVar[int] = ...
        HALTED_USER: ClassVar[int] = ...
        SUCCESS: ClassVar[int] = ...
        SUCCESS_USER: ClassVar[int] = ...

    class Type:
        ARMIJO: ClassVar[str] = ...
        GPCG: ClassVar[str] = ...
        IPM: ClassVar[str] = ...
        MORETHUENTE: ClassVar[str] = ...
        OWARMIJO: ClassVar[str] = ...
        UNIT: ClassVar[str] = ...
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def apply(self, x: Vec, g: Vec, s: Vec) -> tuple[float, float, str]: ...
    def create(self, comm=...) -> Self: ...
    def destroy(self) -> Self: ...
    def getOptionsPrefix(self) -> str: ...
    def getType(self) -> str: ...
    def setFromOptions(self) -> None: ...
    def setGradient(self, gradient: TAOLSGradientFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setObjective(self, objective: TAOLSObjectiveFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setObjectiveGradient(self, objgrad: TAOLSObjectiveGradientFunction, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setOptionsPrefix(self, prefix: str | None = ...) -> None: ...
    def setType(self, ls_type: Type | str) -> None: ...
    def setUp(self) -> None: ...
    def useTAORoutine(self, tao: TAO) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class TS(Object):
    class ARKIMEXType:
        ARKIMEX1BEE: ClassVar[str] = ...
        ARKIMEX2C: ClassVar[str] = ...
        ARKIMEX2D: ClassVar[str] = ...
        ARKIMEX2E: ClassVar[str] = ...
        ARKIMEX3: ClassVar[str] = ...
        ARKIMEX4: ClassVar[str] = ...
        ARKIMEX5: ClassVar[str] = ...
        ARKIMEXA2: ClassVar[str] = ...
        ARKIMEXARS122: ClassVar[str] = ...
        ARKIMEXARS443: ClassVar[str] = ...
        ARKIMEXBPR3: ClassVar[str] = ...
        ARKIMEXL2: ClassVar[str] = ...
        ARKIMEXPRSSP2: ClassVar[str] = ...

    class ConvergedReason:
        CONVERGED_EVENT: ClassVar[int] = ...
        CONVERGED_ITERATING: ClassVar[int] = ...
        CONVERGED_ITS: ClassVar[int] = ...
        CONVERGED_TIME: ClassVar[int] = ...
        CONVERGED_USER: ClassVar[int] = ...
        DIVERGED_NONLINEAR_SOLVE: ClassVar[int] = ...
        DIVERGED_STEP_REJECTED: ClassVar[int] = ...
        ITERATING: ClassVar[int] = ...

    class DIRKType:
        DIRK657A: ClassVar[str] = ...
        DIRK658A: ClassVar[str] = ...
        DIRK7510SAL: ClassVar[str] = ...
        DIRK759A: ClassVar[str] = ...
        DIRK8614A: ClassVar[str] = ...
        DIRK8616SAL: ClassVar[str] = ...
        DIRKES122SAL: ClassVar[str] = ...
        DIRKES213SAL: ClassVar[str] = ...
        DIRKES324SAL: ClassVar[str] = ...
        DIRKES325SAL: ClassVar[str] = ...
        DIRKES648SA: ClassVar[str] = ...
        DIRKES7510SA: ClassVar[str] = ...
        DIRKES8516SAL: ClassVar[str] = ...
        DIRKS212: ClassVar[str] = ...
        DIRKS659A: ClassVar[str] = ...
        DIRKS7511SAL: ClassVar[str] = ...

    class EquationType:
        DAE_IMPLICIT_INDEX1: ClassVar[int] = ...
        DAE_IMPLICIT_INDEX2: ClassVar[int] = ...
        DAE_IMPLICIT_INDEX3: ClassVar[int] = ...
        DAE_IMPLICIT_INDEXHI: ClassVar[int] = ...
        DAE_SEMI_EXPLICIT_INDEX1: ClassVar[int] = ...
        DAE_SEMI_EXPLICIT_INDEX2: ClassVar[int] = ...
        DAE_SEMI_EXPLICIT_INDEX3: ClassVar[int] = ...
        DAE_SEMI_EXPLICIT_INDEXHI: ClassVar[int] = ...
        EXPLICIT: ClassVar[int] = ...
        IMPLICIT: ClassVar[int] = ...
        ODE_EXPLICIT: ClassVar[int] = ...
        ODE_IMPLICIT: ClassVar[int] = ...
        UNSPECIFIED: ClassVar[int] = ...

    class ExactFinalTime:
        INTERPOLATE: ClassVar[int] = ...
        MATCHSTEP: ClassVar[int] = ...
        STEPOVER: ClassVar[int] = ...
        UNSPECIFIED: ClassVar[int] = ...

    class ExactFinalTimeOption:
        INTERPOLATE: ClassVar[int] = ...
        MATCHSTEP: ClassVar[int] = ...
        STEPOVER: ClassVar[int] = ...
        UNSPECIFIED: ClassVar[int] = ...

    class ProblemType:
        LINEAR: ClassVar[int] = ...
        NONLINEAR: ClassVar[int] = ...

    class RKType:
        RK1FE: ClassVar[str] = ...
        RK2A: ClassVar[str] = ...
        RK2B: ClassVar[str] = ...
        RK3: ClassVar[str] = ...
        RK3BS: ClassVar[str] = ...
        RK4: ClassVar[str] = ...
        RK5BS: ClassVar[str] = ...
        RK5DP: ClassVar[str] = ...
        RK5F: ClassVar[str] = ...
        RK6VR: ClassVar[str] = ...
        RK7VR: ClassVar[str] = ...
        RK8VR: ClassVar[str] = ...

    class Type:
        ALPHA: ClassVar[str] = ...
        ALPHA2: ClassVar[str] = ...
        ARKIMEX: ClassVar[str] = ...
        BASICSYMPLECTIC: ClassVar[str] = ...
        BDF: ClassVar[str] = ...
        BE: ClassVar[str] = ...
        BEULER: ClassVar[str] = ...
        CN: ClassVar[str] = ...
        CRANK_NICOLSON: ClassVar[str] = ...
        DIRK: ClassVar[str] = ...
        DISCGRAD: ClassVar[str] = ...
        EIMEX: ClassVar[str] = ...
        EULER: ClassVar[str] = ...
        FE: ClassVar[str] = ...
        GLEE: ClassVar[str] = ...
        GLLE: ClassVar[str] = ...
        MIMEX: ClassVar[str] = ...
        MPRK: ClassVar[str] = ...
        PSEUDO: ClassVar[str] = ...
        PYTHON: ClassVar[str] = ...
        RADAU5: ClassVar[str] = ...
        RK: ClassVar[str] = ...
        ROSW: ClassVar[str] = ...
        RUNGE_KUTTA: ClassVar[str] = ...
        SSP: ClassVar[str] = ...
        SUNDIALS: ClassVar[str] = ...
        TH: ClassVar[str] = ...
        THETA: ClassVar[str] = ...
    
    appctx: TS.appctx
    atol: TS.atol
    converged: TS.converged
    diverged: TS.diverged
    dm: TS.dm
    equation_type: TS.equation_type
    iterating: TS.iterating
    ksp: TS.ksp
    max_steps: TS.max_steps
    max_time: TS.max_time
    problem_type: TS.problem_type
    reason: TS.reason
    rtol: TS.rtol
    snes: TS.snes
    step_number: TS.step_number
    time: TS.time
    time_step: TS.time_step
    vec_sol: TS.vec_sol
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def adjointReset(self) -> None: ...
    def adjointSetSteps(self, adjoint_steps: int) -> None: ...
    def adjointSetUp(self) -> None: ...
    def adjointSolve(self) -> None: ...
    def adjointStep(self) -> None: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def cancelMonitor(self, *args, **kwargs): ...
    def clone(self) -> TS: ...
    def computeI2Function(self, t: float, x: Vec, xdot: Vec, xdotdot: Vec, f: Vec) -> None: ...
    def computeI2Jacobian(self, t: float, x: Vec, xdot: Vec, xdotdot: Vec, v: float, a: float, J: Mat, P: Mat | None = ...) -> None: ...
    def computeIFunction(self, t: float, x: Vec, xdot: Vec, f: Vec, imex: bool = ...) -> None: ...
    def computeIJacobian(self, t: float, x: Vec, xdot: Vec, a: float, J: Mat, P: Mat | None = ..., imex: bool = ...) -> None: ...
    def computeIJacobianP(self, t: float, x: Vec, xdot: Vec, a: float, J: Mat, imex: bool = ...) -> None: ...
    def computeRHSFunction(self, t: float, x: Vec, f: Vec) -> None: ...
    def computeRHSFunctionLinear(self, t: float, x: Vec, f: Vec) -> None: ...
    def computeRHSJacobian(self, t: float, x: Vec, J: Mat, P: Mat | None = ...) -> None: ...
    def computeRHSJacobianConstant(self, t: float, x: Vec, J: Mat, P: Mat | None = ...) -> None: ...
    def computeRHSJacobianP(self, t: float, x: Vec, J: Mat) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createPython(self, context: Any = ..., comm: Comm | None = ...) -> Self: ...
    def createQuadratureTS(self, forward: bool = ...) -> TS: ...
    def destroy(self) -> Self: ...
    def getARKIMEXType(self) -> str: ...
    def getAlphaParams(self) -> tuple[float, float, float]: ...
    def getAppCtx(self) -> Any: ...
    def getConvergedReason(self) -> ConvergedReason: ...
    def getCostGradients(self) -> tuple[list[Vec], list[Vec]]: ...
    def getCostIntegral(self) -> Vec: ...
    def getDIRKType(self) -> str: ...
    def getDM(self) -> DM: ...
    def getEquationType(self) -> EquationType: ...
    def getEvaluationSolutions(self) -> tuple[ArrayReal, list[Vec]]: ...
    def getEvaluationTimes(self) -> ArrayReal: ...
    def getI2Function(self) -> tuple[Vec, TSI2Function]: ...
    def getI2Jacobian(self) -> tuple[Mat, Mat, TSI2Jacobian]: ...
    def getIFunction(self) -> tuple[Vec, TSIFunction]: ...
    def getIJacobian(self) -> tuple[Mat, Mat, TSIJacobian]: ...
    def getKSP(self) -> KSP: ...
    def getKSPIterations(self) -> int: ...
    def getMaxSteps(self) -> int: ...
    def getMaxTime(self) -> float: ...
    def getMonitor(self) -> list[tuple[TSMonitorFunction, tuple[Any, ...], dict[str, Any]]]: ...
    def getNumEvents(self) -> int: ...
    def getOptionsPrefix(self) -> str: ...
    def getPostStep(self) -> tuple[TSPostStepFunction, tuple[Any, ...] | None, dict[str, Any] | None]: ...
    def getPreStep(self) -> tuple[TSPreStepFunction, tuple[Any, ...] | None, dict[str, Any] | None]: ...
    def getPrevTime(self) -> float: ...
    def getProblemType(self) -> ProblemType: ...
    def getPythonContext(self) -> Any: ...
    def getPythonType(self) -> str: ...
    def getQuadratureTS(self) -> tuple[bool, TS]: ...
    def getRHSFunction(self) -> tuple[Vec, TSRHSFunction]: ...
    def getRHSJacobian(self) -> tuple[Mat, Mat, TSRHSJacobian]: ...
    def getRKType(self) -> str: ...
    def getSNES(self) -> SNES: ...
    def getSNESFailures(self) -> int: ...
    def getSNESIterations(self) -> int: ...
    def getSolution(self) -> Vec: ...
    def getSolution2(self) -> tuple[Vec, Vec]: ...
    def getSolveTime(self) -> float: ...
    def getStepLimits(self) -> tuple[float, float]: ...
    def getStepNumber(self) -> int: ...
    def getStepRejections(self) -> int: ...
    def getTheta(self) -> float: ...
    def getThetaEndpoint(self) -> bool: ...
    def getTime(self) -> float: ...
    def getTimeSpan(self, *args, **kwargs): ...
    def getTimeSpanSolutions(self) -> list[Vec]: ...
    def getTimeStep(self) -> float: ...
    def getTolerances(self) -> tuple[float, float]: ...
    def getType(self) -> str: ...
    def interpolate(self, t: float, u: Vec) -> None: ...
    def load(self, viewer: Viewer) -> None: ...
    def monitor(self, step: int, time: float, u: Vec | None = ...) -> None: ...
    def monitorCancel(self) -> None: ...
    def removeTrajectory(self) -> None: ...
    def reset(self) -> None: ...
    def restartStep(self) -> None: ...
    def rollBack(self) -> None: ...
    def setARKIMEXFastSlowSplit(self, flag: bool) -> None: ...
    def setARKIMEXFullyImplicit(self, flag: bool) -> None: ...
    def setARKIMEXType(self, ts_type: ARKIMEXType | str) -> None: ...
    def setAlphaParams(self, alpha_m: float | None = ..., alpha_f: float | None = ..., gamma: float | None = ...) -> None: ...
    def setAlphaRadius(self, radius: float) -> None: ...
    def setAppCtx(self, appctx: Any) -> None: ...
    def setConvergedReason(self, reason: ConvergedReason) -> None: ...
    def setCostGradients(self, vl: Vec | Sequence[Vec] | None, vm: Vec | Sequence[Vec] | None = ...) -> None: ...
    def setDIRKType(self, ts_type: DIRKType | str) -> None: ...
    def setDM(self, dm: DM) -> None: ...
    def setEquationType(self, eqtype: EquationType) -> None: ...
    def setErrorIfStepFails(self, flag: bool = ...) -> None: ...
    def setEvaluationTimes(self, tspan: Sequence[float]) -> None: ...
    def setEventHandler(self, direction: Sequence[int], terminate: Sequence[bool], indicator: TSIndicatorFunction | None, postevent: TSPostEventFunction = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setEventTolerances(self, tol: float = ..., vtol: Sequence[float] = ...) -> None: ...
    def setExactFinalTime(self, option: ExactFinalTime) -> None: ...
    def setFromOptions(self) -> None: ...
    def setI2Function(self, function: TSI2Function | None, f: Vec | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setI2Jacobian(self, jacobian: TSI2Jacobian | None, J: Mat | None = ..., P: Mat | None = ..., args=..., kargs=...) -> None: ...
    def setIFunction(self, function: TSIFunction | None, f: Vec | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setIJacobian(self, jacobian: TSIJacobian | None, J: Mat | None = ..., P: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setIJacobianP(self, jacobian, J: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setMaxSNESFailures(self, n: int) -> None: ...
    def setMaxStepRejections(self, n: int) -> None: ...
    def setMaxSteps(self, max_steps: int) -> None: ...
    def setMaxTime(self, max_time: float) -> None: ...
    def setMonitor(self, monitor: TSMonitorFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def setPostStep(self, poststep: TSPostStepFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setPreStep(self, prestep: TSPreStepFunction | None, args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setProblemType(self, ptype: ProblemType) -> None: ...
    def setPythonContext(self, context: Any) -> None: ...
    def setPythonType(self, py_type: str) -> None: ...
    def setRHSFunction(self, function: TSRHSFunction | None, f: Vec | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setRHSJacobian(self, jacobian: TSRHSJacobian | None, J: Mat | None = ..., P: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setRHSJacobianP(self, rhsjacobianp: TSRHSJacobianP | None, A: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setRHSSplitIFunction(self, splitname: str, function: TSIFunction, r: Vec | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setRHSSplitIJacobian(self, splitname: str, jacobian: TSRHSJacobian, J: Mat | None = ..., P: Mat | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setRHSSplitIS(self, splitname: str, iss: IS) -> None: ...
    def setRHSSplitRHSFunction(self, splitname: str, function: TSRHSFunction, r: Vec | None = ..., args: tuple[Any, ...] | None = ..., kargs: dict[str, Any] | None = ...) -> None: ...
    def setRKType(self, ts_type: RKType | str) -> None: ...
    def setSaveTrajectory(self) -> None: ...
    def setSolution(self, u: Vec) -> None: ...
    def setSolution2(self, u: Vec, v: Vec) -> None: ...
    def setStepLimits(self, hmin: float, hmax: float) -> None: ...
    def setStepNumber(self, step_number: int) -> None: ...
    def setTheta(self, theta: float) -> None: ...
    def setThetaEndpoint(self, flag=...) -> None: ...
    def setTime(self, t: float) -> None: ...
    def setTimeSpan(self, tspan: Sequence[float]) -> None: ...
    def setTimeStep(self, time_step: float) -> None: ...
    def setTolerances(self, rtol: float = ..., atol: float = ...) -> None: ...
    def setType(self, ts_type: Type | str) -> None: ...
    def setUp(self) -> None: ...
    def solve(self, u: Vec | None = ...) -> None: ...
    def step(self) -> None: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...

class Vec(Object):
    class Option:
        IGNORE_NEGATIVE_INDICES: ClassVar[int] = ...
        IGNORE_OFF_PROC_ENTRIES: ClassVar[int] = ...

    class Type:
        CUDA: ClassVar[str] = ...
        HIP: ClassVar[str] = ...
        KOKKOS: ClassVar[str] = ...
        MPI: ClassVar[str] = ...
        MPICUDA: ClassVar[str] = ...
        MPIHIP: ClassVar[str] = ...
        MPIKOKKOS: ClassVar[str] = ...
        MPIVIENNACL: ClassVar[str] = ...
        NEST: ClassVar[str] = ...
        SEQ: ClassVar[str] = ...
        SEQCUDA: ClassVar[str] = ...
        SEQHIP: ClassVar[str] = ...
        SEQKOKKOS: ClassVar[str] = ...
        SEQVIENNACL: ClassVar[str] = ...
        SHARED: ClassVar[str] = ...
        STANDARD: ClassVar[str] = ...
        VIENNACL: ClassVar[str] = ...
    concatenate: ClassVar[method] = ...
    
    array: Vec.array
    array_r: Vec.array_r
    array_w: Vec.array_w
    block_size: Vec.block_size
    buffer: Vec.buffer
    buffer_r: Vec.buffer_r
    buffer_w: Vec.buffer_w
    local_size: Vec.local_size
    owner_range: Vec.owner_range
    owner_ranges: Vec.owner_ranges
    size: Vec.size
    sizes: Vec.sizes
    __array_interface__: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def abs(self) -> None: ...
    def appendOptionsPrefix(self, prefix: str | None) -> None: ...
    def assemble(self) -> None: ...
    def assemblyBegin(self) -> None: ...
    def assemblyEnd(self) -> None: ...
    def attachDLPackInfo(self, vec: Vec | None = ..., dltensor=...) -> Self: ...
    def axpby(self, alpha: Scalar, beta: Scalar, x: Vec) -> None: ...
    def axpy(self, alpha: Scalar, x: Vec) -> None: ...
    def aypx(self, alpha: Scalar, x: Vec) -> None: ...
    def bindToCPU(self, flg: bool) -> None: ...
    def boundToCPU(self) -> bool: ...
    def chop(self, tol: float) -> None: ...
    def clearDLPackInfo(self) -> Self: ...
    def conjugate(self) -> None: ...
    def copy(self, result: Vec | None = ...) -> Vec: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createCUDAWithArrays(self, cpuarray: Sequence[Scalar] | None = ..., cudahandle: Any | None = ..., size: LayoutSizeSpec | None = ..., bsize: int | None = ..., comm: Comm | None = ...) -> Self: ...
    def createGhost(self, ghosts: Sequence[int], size: LayoutSizeSpec, bsize: int | None = ..., comm: Comm | None = ...) -> Self: ...
    def createGhostWithArray(self, ghosts: Sequence[int], array: Sequence[Scalar], size: LayoutSizeSpec | None = ..., bsize: int | None = ..., comm: Comm | None = ...) -> Self: ...
    def createHIPWithArrays(self, cpuarray: Sequence[Scalar] | None = ..., hiphandle: Any | None = ..., size: LayoutSizeSpec | None = ..., bsize: int | None = ..., comm: Comm | None = ...) -> Self: ...
    def createLocalVector(self) -> Vec: ...
    def createMPI(self, size: LayoutSizeSpec, bsize: int | None = ..., comm: Comm | None = ...) -> Self: ...
    def createNest(self, vecs: Sequence[Vec], isets: Sequence[IS] = ..., comm: Comm | None = ...) -> Self: ...
    def createSeq(self, size: LayoutSizeSpec, bsize: int | None = ..., comm: Comm | None = ...) -> Self: ...
    def createShared(self, size: LayoutSizeSpec, bsize: int | None = ..., comm: Comm | None = ...) -> Self: ...
    def createViennaCLWithArrays(self, cpuarray: Sequence[Scalar] | None = ..., viennaclvechandle: Any | None = ..., size: LayoutSizeSpec | None = ..., bsize: int | None = ..., comm: Comm | None = ...) -> Self: ...
    def createWithArray(self, array: Sequence[Scalar], size: LayoutSizeSpec | None = ..., bsize: int | None = ..., comm: Comm | None = ...) -> Self: ...
    def createWithDLPack(self, dltensor, size: LayoutSizeSpec | None = ..., bsize: int | None = ..., comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def dot(self, vec: Vec) -> Scalar: ...
    def dotBegin(self, vec: Vec) -> None: ...
    def dotEnd(self, vec: Vec) -> Scalar: ...
    def dotNorm2(self, vec: Vec) -> tuple[Scalar, float]: ...
    def duplicate(self, array: Sequence[Scalar] | None = ...) -> Vec: ...
    def equal(self, vec: Vec) -> bool: ...
    def exp(self) -> None: ...
    def getArray(self, readonly: bool = ...) -> ArrayScalar: ...
    def getBlockSize(self) -> int: ...
    @overload
    def getBuffer(self, readonly: bool = ...) -> Any: ...
    @overload
    def getBuffer(self) -> Any: ...
    @overload
    def getBuffer(self) -> Any: ...
    def getCLContextHandle(self) -> int: ...
    def getCLMemHandle(self, mode: AccessModeSpec = ...) -> int: ...
    def getCLQueueHandle(self) -> int: ...
    def getCUDAHandle(self, mode: AccessModeSpec = ...) -> Any: ...
    def getDM(self) -> DM: ...
    def getGhostIS(self) -> IS: ...
    def getHIPHandle(self, mode: AccessModeSpec = ...) -> Any: ...
    def getLGMap(self) -> LGMap: ...
    def getLocalSize(self) -> int: ...
    def getLocalVector(self, lvec: Vec, readonly: bool = ...) -> None: ...
    def getNestSubVecs(self) -> list[Vec]: ...
    def getOffloadMask(self) -> int: ...
    def getOptionsPrefix(self) -> str: ...
    def getOwnershipRange(self) -> tuple[int, int]: ...
    def getOwnershipRanges(self) -> ArrayInt: ...
    def getSize(self) -> int: ...
    def getSizes(self) -> LayoutSizeSpec: ...
    def getSubVector(self, iset: IS, subvec: Vec | None = ...) -> Vec: ...
    def getType(self) -> str: ...
    def getValue(self, index: int) -> Scalar: ...
    def getValues(self, indices: Sequence[int], values: Sequence[Scalar] | None = ...) -> ArrayScalar: ...
    def getValuesStagStencil(self, indices, values=...) -> None: ...
    def ghostUpdate(self, addv: InsertModeSpec = ..., mode: ScatterModeSpec = ...) -> None: ...
    def ghostUpdateBegin(self, addv: InsertModeSpec = ..., mode: ScatterModeSpec = ...) -> None: ...
    def ghostUpdateEnd(self, addv: InsertModeSpec = ..., mode: ScatterModeSpec = ...) -> None: ...
    def isaxpy(self, idx: IS, alpha: Scalar, x: Vec) -> None: ...
    def isset(self, idx: IS, alpha: Scalar) -> None: ...
    def load(self, viewer: Viewer) -> Self: ...
    @overload
    def localForm(self) -> Any: ...
    @overload
    def localForm(self) -> Any: ...
    def log(self) -> None: ...
    def mDot(self, vecs: Sequence[Vec], out: ArrayScalar | None = ...) -> ArrayScalar: ...
    def mDotBegin(self, vecs: Sequence[Vec], out: ArrayScalar) -> None: ...
    def mDotEnd(self, vecs: Sequence[Vec], out: ArrayScalar) -> ArrayScalar: ...
    def max(self) -> tuple[int, float]: ...
    def maxPointwiseDivide(self, vec: Vec) -> float: ...
    def maxpy(self, alphas: Sequence[Scalar], vecs: Sequence[Vec]) -> None: ...
    def mean(self) -> Scalar: ...
    def min(self) -> tuple[int, float]: ...
    def mtDot(self, vecs: Sequence[Vec], out: ArrayScalar | None = ...) -> ArrayScalar: ...
    def mtDotBegin(self, vecs: Sequence[Vec], out: ArrayScalar) -> None: ...
    def mtDotEnd(self, vecs: Sequence[Vec], out: ArrayScalar) -> ArrayScalar: ...
    def norm(self, norm_type: NormTypeSpec = ...) -> float | tuple[float, float]: ...
    def normBegin(self, norm_type: NormTypeSpec = ...) -> None: ...
    def normEnd(self, norm_type: NormTypeSpec = ...) -> float | tuple[float, float]: ...
    def normalize(self) -> float: ...
    def permute(self, order: IS, invert: bool = ...) -> None: ...
    def placeArray(self, array: Sequence[Scalar]) -> None: ...
    def pointwiseDivide(self, x: Vec, y: Vec) -> None: ...
    def pointwiseMax(self, x: Vec, y: Vec) -> None: ...
    def pointwiseMaxAbs(self, x: Vec, y: Vec) -> None: ...
    def pointwiseMin(self, x: Vec, y: Vec) -> None: ...
    def pointwiseMult(self, x: Vec, y: Vec) -> None: ...
    def reciprocal(self) -> None: ...
    def resetArray(self, force: bool = ...) -> ArrayScalar | None: ...
    def restoreCLMemHandle(self) -> None: ...
    def restoreCUDAHandle(self, handle: Any, mode: AccessModeSpec = ...) -> None: ...
    def restoreHIPHandle(self, handle: Any, mode: AccessModeSpec = ...) -> None: ...
    def restoreLocalVector(self, lvec: Vec, readonly: bool = ...) -> None: ...
    def restoreSubVector(self, iset: IS, subvec: Vec) -> None: ...
    def scale(self, alpha: Scalar) -> None: ...
    def set(self, alpha: Scalar) -> None: ...
    def setArray(self, array: Sequence[Scalar]) -> None: ...
    def setBlockSize(self, bsize: int) -> None: ...
    def setDM(self, dm: DM) -> None: ...
    def setFromOptions(self) -> None: ...
    def setLGMap(self, lgmap: LGMap) -> None: ...
    def setMPIGhost(self, ghosts: Sequence[int]) -> None: ...
    def setNestSubVecs(self, sx: Sequence[Vec], idxm: Sequence[int] | None = ...) -> None: ...
    def setOption(self, option: Option, flag: bool) -> None: ...
    def setOptionsPrefix(self, prefix: str | None) -> None: ...
    def setRandom(self, random: Random | None = ...) -> None: ...
    def setSizes(self, size: LayoutSizeSpec, bsize: int | None = ...) -> None: ...
    def setType(self, vec_type: Type | str) -> None: ...
    def setUp(self) -> Self: ...
    def setValue(self, index: int, value: Scalar, addv: InsertModeSpec = ...) -> None: ...
    def setValueLocal(self, index: int, value: Scalar, addv: InsertModeSpec = ...) -> None: ...
    def setValues(self, indices: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesBlocked(self, indices: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesBlockedLocal(self, indices: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesLocal(self, indices: Sequence[int], values: Sequence[Scalar], addv: InsertModeSpec = ...) -> None: ...
    def setValuesStagStencil(self, indices, values, addv=...) -> None: ...
    def shift(self, alpha: Scalar) -> None: ...
    def sqrtabs(self) -> None: ...
    def strideGather(self, field: int, vec: Vec, addv: InsertModeSpec = ...) -> None: ...
    def strideMax(self, field: int) -> tuple[int, float]: ...
    def strideMin(self, field: int) -> tuple[int, float]: ...
    def strideNorm(self, field: int, norm_type: NormTypeSpec = ...) -> float | tuple[float, float]: ...
    def strideScale(self, field: int, alpha: Scalar) -> None: ...
    def strideScatter(self, field: int, vec: Vec, addv: InsertModeSpec = ...) -> None: ...
    def strideSum(self, field: int) -> Scalar: ...
    def sum(self) -> Scalar: ...
    def swap(self, vec: Vec) -> None: ...
    def tDot(self, vec: Vec) -> Scalar: ...
    def tDotBegin(self, vec: Vec) -> None: ...
    def tDotEnd(self, vec: Vec) -> Scalar: ...
    def toDLPack(self, mode: AccessModeSpec = ...) -> Any: ...
    def view(self, viewer: Viewer | None = ...) -> None: ...
    def waxpy(self, alpha: Scalar, x: Vec, y: Vec) -> None: ...
    def zeroEntries(self) -> None: ...
    def __abs__(self): ...
    def __add__(self, other): ...
    def __buffer__(self, *args, **kwargs): ...
    def __delitem__(self, other) -> None: ...
    def __div__(self, other) -> Any: ...
    def __dlpack__(self, stream=...) -> Any: ...
    def __dlpack_device__(self) -> Any: ...
    def __enter__(self) -> Any: ...
    def __exit__(self, *exc) -> Any: ...
    def __getitem__(self, index): ...
    def __iadd__(self, other): ...
    def __idiv__(self, other) -> Any: ...
    def __imul__(self, other): ...
    def __isub__(self, other): ...
    def __itruediv__(self, other): ...
    def __matmul__(self, *args, **kwargs): ...
    def __mul__(self, other): ...
    def __neg__(self): ...
    def __pos__(self): ...
    def __radd__(self, other): ...
    def __rdiv__(self, other) -> Any: ...
    def __release_buffer__(self, *args, **kwargs): ...
    def __rmatmul__(self, *args, **kwargs): ...
    def __rmul__(self, other): ...
    def __rsub__(self, other): ...
    def __rtruediv__(self, other): ...
    def __setitem__(self, index, object) -> None: ...
    def __sub__(self, other): ...
    def __truediv__(self, other): ...

class Viewer(Object):
    class DrawSize:
        FULL: ClassVar[int] = ...
        FULL_SIZE: ClassVar[int] = ...
        HALF: ClassVar[int] = ...
        HALF_SIZE: ClassVar[int] = ...
        QUARTER: ClassVar[int] = ...
        QUARTER_SIZE: ClassVar[int] = ...
        THIRD: ClassVar[int] = ...
        THIRD_SIZE: ClassVar[int] = ...

    class FileMode:
        A: ClassVar[int] = ...
        APPEND: ClassVar[int] = ...
        APPEND_UPDATE: ClassVar[int] = ...
        AU: ClassVar[int] = ...
        R: ClassVar[int] = ...
        READ: ClassVar[int] = ...
        U: ClassVar[int] = ...
        UA: ClassVar[int] = ...
        UPDATE: ClassVar[int] = ...
        W: ClassVar[int] = ...
        WRITE: ClassVar[int] = ...

    class Format:
        ASCII_COMMON: ClassVar[int] = ...
        ASCII_CSV: ClassVar[int] = ...
        ASCII_DENSE: ClassVar[int] = ...
        ASCII_FACTOR_INFO: ClassVar[int] = ...
        ASCII_GLVIS: ClassVar[int] = ...
        ASCII_IMPL: ClassVar[int] = ...
        ASCII_INDEX: ClassVar[int] = ...
        ASCII_INFO: ClassVar[int] = ...
        ASCII_INFO_DETAIL: ClassVar[int] = ...
        ASCII_LATEX: ClassVar[int] = ...
        ASCII_MATHEMATICA: ClassVar[int] = ...
        ASCII_MATLAB: ClassVar[int] = ...
        ASCII_MATRIXMARKET: ClassVar[int] = ...
        ASCII_PCICE: ClassVar[int] = ...
        ASCII_PYTHON: ClassVar[int] = ...
        ASCII_SYMMODU: ClassVar[int] = ...
        ASCII_XML: ClassVar[int] = ...
        BINARY_MATLAB: ClassVar[int] = ...
        DEFAULT: ClassVar[int] = ...
        DRAW_BASIC: ClassVar[int] = ...
        DRAW_CONTOUR: ClassVar[int] = ...
        DRAW_LG: ClassVar[int] = ...
        DRAW_LG_XRANGE: ClassVar[int] = ...
        DRAW_PORTS: ClassVar[int] = ...
        FAILED: ClassVar[int] = ...
        HDF5_MAT: ClassVar[int] = ...
        HDF5_PETSC: ClassVar[int] = ...
        HDF5_VIZ: ClassVar[int] = ...
        HDF5_XDMF: ClassVar[int] = ...
        LOAD_BALANCE: ClassVar[int] = ...
        NATIVE: ClassVar[int] = ...
        NOFORMAT: ClassVar[int] = ...
        VTK_VTR: ClassVar[int] = ...
        VTK_VTS: ClassVar[int] = ...
        VTK_VTU: ClassVar[int] = ...

    class Mode:
        A: ClassVar[int] = ...
        APPEND: ClassVar[int] = ...
        APPEND_UPDATE: ClassVar[int] = ...
        AU: ClassVar[int] = ...
        R: ClassVar[int] = ...
        READ: ClassVar[int] = ...
        U: ClassVar[int] = ...
        UA: ClassVar[int] = ...
        UPDATE: ClassVar[int] = ...
        W: ClassVar[int] = ...
        WRITE: ClassVar[int] = ...

    class Size:
        A: ClassVar[int] = ...
        APPEND: ClassVar[int] = ...
        APPEND_UPDATE: ClassVar[int] = ...
        AU: ClassVar[int] = ...
        R: ClassVar[int] = ...
        READ: ClassVar[int] = ...
        U: ClassVar[int] = ...
        UA: ClassVar[int] = ...
        UPDATE: ClassVar[int] = ...
        W: ClassVar[int] = ...
        WRITE: ClassVar[int] = ...

    class Type:
        ADIOS: ClassVar[str] = ...
        ASCII: ClassVar[str] = ...
        BINARY: ClassVar[str] = ...
        DRAW: ClassVar[str] = ...
        EXODUSII: ClassVar[str] = ...
        GLVIS: ClassVar[str] = ...
        HDF5: ClassVar[str] = ...
        MATHEMATICA: ClassVar[str] = ...
        MATLAB: ClassVar[str] = ...
        PYTHON: ClassVar[str] = ...
        PYVISTA: ClassVar[str] = ...
        SAWS: ClassVar[str] = ...
        SOCKET: ClassVar[str] = ...
        STRING: ClassVar[str] = ...
        VTK: ClassVar[str] = ...
        VU: ClassVar[str] = ...
    ASCII: ClassVar[method] = ...
    BINARY: ClassVar[method] = ...
    DRAW: ClassVar[method] = ...
    STDERR: ClassVar[method] = ...
    STDOUT: ClassVar[method] = ...
    
    @classmethod
    def __init__(cls) -> Any: ...
    def addASCIITab(self, tabs: int) -> None: ...
    def clearDraw(self) -> None: ...
    def create(self, comm: Comm | None = ...) -> Self: ...
    def createASCII(self, name: str, mode: FileMode | str | None = ..., comm: Comm | None = ...) -> Self: ...
    def createBinary(self, name: str, mode: FileMode | str | None = ..., comm: Comm | None = ...) -> Self: ...
    def createDraw(self, display: str | None = ..., title: str | None = ..., position: tuple[int, int] | None = ..., size: tuple[int, int] | int | None = ..., comm: Comm | None = ...) -> Self: ...
    def createHDF5(self, name: str, mode: FileMode | str | None = ..., comm: Comm | None = ...) -> Self: ...
    def createMPIIO(self, name: str, mode: FileMode | str | None = ..., comm: Comm | None = ...) -> Self: ...
    def createPython(self, context: Any = ..., comm: Comm | None = ...) -> Self: ...
    def createVTK(self, name: str, mode: FileMode | str | None = ..., comm: Comm | None = ...) -> Self: ...
    def destroy(self) -> Self: ...
    def flush(self) -> None: ...
    def getASCIITab(self) -> int: ...
    def getFileMode(self) -> FileMode: ...
    def getFileName(self) -> str: ...
    def getFormat(self) -> Format: ...
    def getPythonContext(self) -> Any: ...
    def getPythonType(self) -> str: ...
    def getSubViewer(self, comm: Comm | None = ...) -> Viewer: ...
    def getType(self) -> str: ...
    def popASCIISynchronized(self) -> None: ...
    def popASCIITab(self) -> None: ...
    def popFormat(self) -> None: ...
    def printfASCII(self, msg: str) -> None: ...
    def printfASCIISynchronized(self, msg: str) -> None: ...
    def pushASCIISynchronized(self) -> None: ...
    def pushASCIITab(self) -> None: ...
    def pushFormat(self, format: Format) -> None: ...
    def restoreSubViewer(self, sub: Viewer) -> None: ...
    def setASCIITab(self, tabs: int) -> None: ...
    def setDrawInfo(self, display: str | None = ..., title: str | None = ..., position: tuple[int, int] | None = ..., size: tuple[int, int] | int | None = ...) -> None: ...
    def setFileMode(self, mode: FileMode | str) -> None: ...
    def setFileName(self, name: str) -> None: ...
    def setFromOptions(self) -> None: ...
    def setPythonContext(self, context: Any) -> None: ...
    def setPythonType(self, py_type: str) -> None: ...
    def setType(self, vwr_type: Type | str) -> None: ...
    def setUp(self) -> Self: ...
    def subtractASCIITab(self, tabs: int) -> None: ...
    def useASCIITabs(self, flag: bool) -> None: ...
    def view(self, obj: Viewer | Object | None = ...) -> None: ...
    def viewObjectPython(self, obj: Object) -> None: ...
    def __call__(self, *args, **kwargs): ...

class ViewerHDF5(Viewer):
    
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, name: str, mode: Viewer.FileMode | str | None = ..., comm: Comm | None = ...) -> Self: ...
    def getGroup(self) -> str: ...
    def getTimestep(self) -> int: ...
    def incrementTimestep(self) -> None: ...
    def popGroup(self) -> None: ...
    def popTimestepping(self) -> None: ...
    def pushGroup(self, group: str) -> None: ...
    def pushTimestepping(self) -> None: ...
    def setTimestep(self, timestep: int) -> None: ...

class _DMComposite_access:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __enter__(self) -> Any: ...
    def __exit__(self, *exc) -> Any: ...

class _DMDA_Vec_array:
    
    array: Incomplete
    shape: Incomplete
    sizes: Incomplete
    starts: Incomplete
    strides: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __delitem__(self, other) -> None: ...
    def __enter__(self) -> Any: ...
    def __exit__(self, *exc) -> Any: ...
    def __getitem__(self, index): ...
    def __setitem__(self, index, object) -> None: ...

class _IS_buffer:
    
    __array_interface__: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __buffer__(self, *args, **kwargs): ...
    def __enter__(self) -> Any: ...
    def __exit__(self, *exc) -> Any: ...
    def __release_buffer__(self, *args, **kwargs): ...

class _Vec_LocalForm:
    def __init__(self, *args, **kwargs) -> None: ...
    def __enter__(self) -> Any: ...
    def __exit__(self, *exc) -> Any: ...

class _Vec_buffer:
    
    __array_interface__: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def __buffer__(self, *args, **kwargs): ...
    def __enter__(self) -> Any: ...
    def __exit__(self, *exc) -> Any: ...
    def __release_buffer__(self, *args, **kwargs): ...
