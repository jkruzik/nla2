import petsc4py.PETSc
from _typeshed import Incomplete
from typing import Any, ClassVar, Self

COMM_NULL: petsc4py.PETSc.Comm
COMM_SELF: petsc4py.PETSc.Comm
COMM_WORLD: petsc4py.PETSc.Comm
CURRENT: int
DECIDE: int
DEFAULT: int
DETERMINE: int
__arch__: str
__pyx_capi__: dict

class BV(petsc4py.PETSc.Object):
    class BlockType:
        CHOL: ClassVar[int] = ...
        GS: ClassVar[int] = ...
        SVQB: ClassVar[int] = ...
        TSQR: ClassVar[int] = ...
        TSQRCHOL: ClassVar[int] = ...

    class MatMultType:
        MAT: ClassVar[int] = ...
        VECS: ClassVar[int] = ...

    class OrthogBlockType:
        CHOL: ClassVar[int] = ...
        GS: ClassVar[int] = ...
        SVQB: ClassVar[int] = ...
        TSQR: ClassVar[int] = ...
        TSQRCHOL: ClassVar[int] = ...

    class OrthogRefineType:
        ALWAYS: ClassVar[int] = ...
        IFNEEDED: ClassVar[int] = ...
        NEVER: ClassVar[int] = ...

    class OrthogType:
        CGS: ClassVar[int] = ...
        MGS: ClassVar[int] = ...

    class RefineType:
        ALWAYS: ClassVar[int] = ...
        IFNEEDED: ClassVar[int] = ...
        NEVER: ClassVar[int] = ...

    class Type:
        CONTIGUOUS: ClassVar[str] = ...
        MAT: ClassVar[str] = ...
        SVEC: ClassVar[str] = ...
        TENSOR: ClassVar[str] = ...
        VECS: ClassVar[str] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def applyMatrix(self, x: Vec, y: Vec) -> Any: ...
    def copy(self, result: BV = ...) -> Any: ...
    def copyColumn(self, j, i) -> Any: ...
    def copyVec(self, j, v: Vec) -> Any: ...
    def create(self, comm=...) -> Any: ...
    def createFromMat(self, A: Mat) -> Any: ...
    def createMat(self) -> Any: ...
    def createVec(self) -> Any: ...
    def destroy(self) -> Any: ...
    def dot(self, Y: BV) -> Any: ...
    def dotColumn(self, j) -> Any: ...
    def dotVec(self, v: Vec) -> Any: ...
    def duplicate(self) -> Any: ...
    def duplicateResize(self, m) -> Any: ...
    def getActiveColumns(self) -> Any: ...
    def getColumn(self, j) -> Any: ...
    def getDefiniteTolerance(self) -> Any: ...
    def getLeadingDimension(self) -> Any: ...
    def getMat(self) -> Any: ...
    def getMatMultMethod(self) -> Any: ...
    def getMatrix(self) -> Any: ...
    def getNumConstraints(self) -> Any: ...
    def getOptionsPrefix(self) -> Any: ...
    def getOrthogonalization(self) -> Any: ...
    def getRandomContext(self) -> Any: ...
    def getSizes(self) -> Any: ...
    def getType(self) -> Any: ...
    def getVecType(self) -> Any: ...
    def insertConstraints(self, C) -> Any: ...
    def insertVec(self, j, w: Vec) -> Any: ...
    def insertVecs(self, s, W, orth: bool) -> Any: ...
    def matMult(self, A: Mat, Y: BV = ...) -> Any: ...
    def matMultColumn(self, A: Mat, j) -> Any: ...
    def matMultHermitianTranspose(self, A: Mat, Y: BV = ...) -> Any: ...
    def matMultHermitianTransposeColumn(self, A: Mat, j) -> Any: ...
    def matMultTransposeColumn(self, A: Mat, j) -> Any: ...
    def matProject(self, A: Mat, Y: BV) -> Any: ...
    def mult(self, alpha, beta, X: BV, Q: Mat) -> Any: ...
    def multColumn(self, alpha, beta, j, q) -> Any: ...
    def multInPlace(self, Q: Mat, s, e) -> Any: ...
    def multVec(self, alpha, beta, y: Vec, q) -> Any: ...
    def norm(self, norm_type=...) -> Any: ...
    def normColumn(self, j: int, norm_type=...) -> Any: ...
    def orthogonalize(self, R: Mat = ..., **kargs) -> Any: ...
    def orthogonalizeColumn(self, j) -> Any: ...
    def orthogonalizeVec(self, v: Vec) -> Any: ...
    def orthonormalizeColumn(self, j, replace=...) -> Any: ...
    def resize(self, m, copy=...) -> Any: ...
    def restoreColumn(self, j, v: Vec) -> Any: ...
    def restoreMat(self, A: Mat) -> Any: ...
    def scale(self, alpha) -> Any: ...
    def scaleColumn(self, j, alpha) -> Any: ...
    def setActiveColumns(self, l, k) -> Any: ...
    def setDefiniteTolerance(self, deftol) -> Any: ...
    def setFromOptions(self) -> Any: ...
    def setLeadingDimension(self, ld) -> Any: ...
    def setMatMultMethod(self, method) -> Any: ...
    def setMatrix(self, mat: Mat, indef: bool) -> Any: ...
    def setNumConstraints(self, nc) -> Any: ...
    def setOptionsPrefix(self, prefix) -> Any: ...
    def setOrthogonalization(self, otype=..., refine=..., eta=..., block=...) -> Any: ...
    def setRandom(self) -> Any: ...
    def setRandomColumn(self, j) -> Any: ...
    def setRandomCond(self, condn) -> Any: ...
    def setRandomContext(self, rnd: Random) -> Any: ...
    def setRandomNormal(self) -> Any: ...
    def setRandomSign(self) -> Any: ...
    def setSizes(self, sizes, m) -> Any: ...
    def setSizesFromVec(self, w: Vec, m) -> Any: ...
    def setType(self, bv_type) -> Any: ...
    def setVecType(self, vec_type) -> Any: ...
    def view(self, viewer: Viewer = ...) -> Any: ...

class BVSVDMethod:
    QR: ClassVar[int] = ...
    QR_CAA: ClassVar[int] = ...
    REFINE: ClassVar[int] = ...

class DS(petsc4py.PETSc.Object):
    class MatType:
        A: ClassVar[int] = ...
        B: ClassVar[int] = ...
        C: ClassVar[int] = ...
        D: ClassVar[int] = ...
        Q: ClassVar[int] = ...
        T: ClassVar[int] = ...
        U: ClassVar[int] = ...
        V: ClassVar[int] = ...
        W: ClassVar[int] = ...
        X: ClassVar[int] = ...
        Y: ClassVar[int] = ...
        Z: ClassVar[int] = ...

    class ParallelType:
        DISTRIBUTED: ClassVar[int] = ...
        REDUNDANT: ClassVar[int] = ...
        SYNCHRONIZED: ClassVar[int] = ...

    class StateType:
        CONDENSED: ClassVar[int] = ...
        INTERMEDIATE: ClassVar[int] = ...
        RAW: ClassVar[int] = ...
        TRUNCATED: ClassVar[int] = ...

    class Type:
        GHEP: ClassVar[str] = ...
        GHIEP: ClassVar[str] = ...
        GNHEP: ClassVar[str] = ...
        GSVD: ClassVar[str] = ...
        HEP: ClassVar[str] = ...
        HSVD: ClassVar[str] = ...
        NEP: ClassVar[str] = ...
        NHEP: ClassVar[str] = ...
        NHEPTS: ClassVar[str] = ...
        PEP: ClassVar[str] = ...
        SVD: ClassVar[str] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    block_size: Incomplete
    compact: Incomplete
    extra_row: Incomplete
    method: Incomplete
    parallel: Incomplete
    refined: Incomplete
    state: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def allocate(self, ld) -> Any: ...
    def cond(self) -> Any: ...
    def create(self, comm=...) -> Any: ...
    def destroy(self) -> Any: ...
    def duplicate(self) -> Any: ...
    def getBlockSize(self) -> Any: ...
    def getCompact(self) -> Any: ...
    def getDimensions(self) -> Any: ...
    def getExtraRow(self) -> Any: ...
    def getGSVDDimensions(self) -> Any: ...
    def getHSVDDimensions(self) -> Any: ...
    def getLeadingDimension(self) -> Any: ...
    def getMat(self, matname) -> Any: ...
    def getMethod(self) -> Any: ...
    def getOptionsPrefix(self) -> Any: ...
    def getPEPCoefficients(self) -> Any: ...
    def getPEPDegree(self) -> Any: ...
    def getParallel(self) -> Any: ...
    def getRefined(self) -> Any: ...
    def getSVDDimensions(self) -> Any: ...
    def getState(self) -> Any: ...
    def getType(self) -> Any: ...
    def reset(self) -> Any: ...
    def restoreMat(self, matname, mat: Mat) -> Any: ...
    def setBlockSize(self, bs) -> Any: ...
    def setCompact(self, comp) -> Any: ...
    def setDimensions(self, n=..., l=..., k=...) -> Any: ...
    def setExtraRow(self, ext) -> Any: ...
    def setFromOptions(self) -> Any: ...
    def setGSVDDimensions(self, m, p) -> Any: ...
    def setHSVDDimensions(self, m) -> Any: ...
    def setIdentity(self, matname) -> Any: ...
    def setMethod(self, meth) -> Any: ...
    def setOptionsPrefix(self, prefix) -> Any: ...
    def setPEPCoefficients(self, pbc) -> Any: ...
    def setPEPDegree(self, deg) -> Any: ...
    def setParallel(self, pmode) -> Any: ...
    def setRefined(self, ref) -> Any: ...
    def setSVDDimensions(self, m) -> Any: ...
    def setState(self, state) -> Any: ...
    def setType(self, ds_type) -> Any: ...
    def solve(self) -> Any: ...
    def truncate(self, n, trim=...) -> Any: ...
    def updateExtraRow(self) -> Any: ...
    def vectors(self, matname=...) -> Any: ...
    def view(self, viewer: Viewer = ...) -> Any: ...

class EPS(petsc4py.PETSc.Object):
    class Balance:
        NONE: ClassVar[int] = ...
        ONESIDE: ClassVar[int] = ...
        TWOSIDE: ClassVar[int] = ...
        USER: ClassVar[int] = ...

    class CISSExtraction:
        HANKEL: ClassVar[int] = ...
        RITZ: ClassVar[int] = ...

    class CISSQuadRule:
        CHEBYSHEV: ClassVar[int] = ...
        TRAPEZOIDAL: ClassVar[int] = ...

    class Conv:
        ABS: ClassVar[int] = ...
        NORM: ClassVar[int] = ...
        REL: ClassVar[int] = ...
        USER: ClassVar[int] = ...

    class ConvergedReason:
        CONVERGED_ITERATING: ClassVar[int] = ...
        CONVERGED_TOL: ClassVar[int] = ...
        CONVERGED_USER: ClassVar[int] = ...
        DIVERGED_BREAKDOWN: ClassVar[int] = ...
        DIVERGED_ITS: ClassVar[int] = ...
        DIVERGED_SYMMETRY_LOST: ClassVar[int] = ...
        ITERATING: ClassVar[int] = ...

    class ErrorType:
        ABSOLUTE: ClassVar[int] = ...
        BACKWARD: ClassVar[int] = ...
        RELATIVE: ClassVar[int] = ...

    class Extraction:
        HARMONIC: ClassVar[int] = ...
        HARMONIC_LARGEST: ClassVar[int] = ...
        HARMONIC_RELATIVE: ClassVar[int] = ...
        HARMONIC_RIGHT: ClassVar[int] = ...
        REFINED: ClassVar[int] = ...
        REFINED_HARMONIC: ClassVar[int] = ...
        RITZ: ClassVar[int] = ...

    class LanczosReorthogType:
        DELAYED: ClassVar[int] = ...
        FULL: ClassVar[int] = ...
        LOCAL: ClassVar[int] = ...
        PARTIAL: ClassVar[int] = ...
        PERIODIC: ClassVar[int] = ...
        SELECTIVE: ClassVar[int] = ...

    class PowerShiftType:
        CONSTANT: ClassVar[int] = ...
        RAYLEIGH: ClassVar[int] = ...
        WILKINSON: ClassVar[int] = ...

    class ProblemType:
        BSE: ClassVar[int] = ...
        GHEP: ClassVar[int] = ...
        GHIEP: ClassVar[int] = ...
        GNHEP: ClassVar[int] = ...
        HEP: ClassVar[int] = ...
        NHEP: ClassVar[int] = ...
        PGNHEP: ClassVar[int] = ...

    class Stop:
        BASIC: ClassVar[int] = ...
        THRESHOLD: ClassVar[int] = ...
        USER: ClassVar[int] = ...

    class Type:
        ARNOLDI: ClassVar[str] = ...
        ARPACK: ClassVar[str] = ...
        BLOPEX: ClassVar[str] = ...
        CHASE: ClassVar[str] = ...
        CISS: ClassVar[str] = ...
        ELEMENTAL: ClassVar[str] = ...
        ELPA: ClassVar[str] = ...
        EVSL: ClassVar[str] = ...
        FEAST: ClassVar[str] = ...
        GD: ClassVar[str] = ...
        JD: ClassVar[str] = ...
        KRYLOVSCHUR: ClassVar[str] = ...
        LANCZOS: ClassVar[str] = ...
        LAPACK: ClassVar[str] = ...
        LOBPCG: ClassVar[str] = ...
        LYAPII: ClassVar[str] = ...
        POWER: ClassVar[str] = ...
        PRIMME: ClassVar[str] = ...
        RQCG: ClassVar[str] = ...
        SCALAPACK: ClassVar[str] = ...
        SUBSPACE: ClassVar[str] = ...
        TRLAN: ClassVar[str] = ...

    class Which:
        ALL: ClassVar[int] = ...
        LARGEST_IMAGINARY: ClassVar[int] = ...
        LARGEST_MAGNITUDE: ClassVar[int] = ...
        LARGEST_REAL: ClassVar[int] = ...
        SMALLEST_IMAGINARY: ClassVar[int] = ...
        SMALLEST_MAGNITUDE: ClassVar[int] = ...
        SMALLEST_REAL: ClassVar[int] = ...
        TARGET_IMAGINARY: ClassVar[int] = ...
        TARGET_MAGNITUDE: ClassVar[int] = ...
        TARGET_REAL: ClassVar[int] = ...
        USER: ClassVar[int] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    bv: Incomplete
    ds: Incomplete
    extraction: Incomplete
    max_it: Incomplete
    problem_type: Incomplete
    purify: Incomplete
    rg: Incomplete
    st: Incomplete
    target: Incomplete
    tol: Incomplete
    track_all: Incomplete
    true_residual: Incomplete
    two_sided: Incomplete
    which: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def appendOptionsPrefix(self, prefix) -> Any: ...
    def cancelMonitor(self) -> Any: ...
    def computeError(self, i: int, etype=...) -> Any: ...
    def create(self, comm=...) -> Any: ...
    def destroy(self) -> Any: ...
    def errorView(self, etype=..., viewer: Viewer = ...) -> Any: ...
    def getArnoldiDelayed(self) -> Any: ...
    def getBV(self) -> Any: ...
    def getBalance(self) -> Any: ...
    def getCISSExtraction(self) -> Any: ...
    def getCISSKSPs(self) -> Any: ...
    def getCISSQuadRule(self) -> Any: ...
    def getCISSRefinement(self) -> Any: ...
    def getCISSSizes(self) -> Any: ...
    def getCISSThreshold(self) -> Any: ...
    def getCISSUseST(self) -> Any: ...
    def getConverged(self) -> Any: ...
    def getConvergedReason(self) -> Any: ...
    def getConvergenceTest(self) -> Any: ...
    def getDS(self) -> Any: ...
    def getDimensions(self) -> Any: ...
    def getEigenpair(self, i: int, Vr: Vec = ..., Vi: Vec = ...) -> Any: ...
    def getEigenvalue(self, i: int) -> Any: ...
    def getEigenvector(self, i: int, Vr: Vec, Vi: Vec = ...) -> Any: ...
    def getErrorEstimate(self, i: int) -> Any: ...
    def getExtraction(self) -> Any: ...
    def getGDBOrth(self) -> Any: ...
    def getGDBlockSize(self) -> Any: ...
    def getGDDoubleExpansion(self) -> Any: ...
    def getGDInitialSize(self) -> Any: ...
    def getGDKrylovStart(self) -> Any: ...
    def getGDRestart(self) -> Any: ...
    def getInterval(self) -> Any: ...
    def getInvariantSubspace(self) -> Any: ...
    def getIterationNumber(self) -> Any: ...
    def getJDBOrth(self) -> Any: ...
    def getJDBlockSize(self) -> Any: ...
    def getJDConstCorrectionTol(self) -> Any: ...
    def getJDFix(self) -> Any: ...
    def getJDInitialSize(self) -> Any: ...
    def getJDKrylovStart(self) -> Any: ...
    def getJDRestart(self) -> Any: ...
    def getKrylovSchurBSEType(self) -> Any: ...
    def getKrylovSchurDetectZeros(self) -> Any: ...
    def getKrylovSchurDimensions(self) -> Any: ...
    def getKrylovSchurInertias(self) -> Any: ...
    def getKrylovSchurKSP(self) -> Any: ...
    def getKrylovSchurLocking(self) -> Any: ...
    def getKrylovSchurPartitions(self) -> Any: ...
    def getKrylovSchurRestart(self) -> Any: ...
    def getKrylovSchurSubcommInfo(self) -> Any: ...
    def getKrylovSchurSubcommMats(self) -> Any: ...
    def getKrylovSchurSubcommPairs(self, i: int, V: Vec) -> Any: ...
    def getKrylovSchurSubintervals(self) -> Any: ...
    def getLOBPCGBlockSize(self) -> Any: ...
    def getLOBPCGLocking(self) -> Any: ...
    def getLOBPCGRestart(self) -> Any: ...
    def getLanczosReorthogType(self) -> Any: ...
    def getLeftEigenvector(self, i: int, Wr: Vec, Wi: Vec = ...) -> Any: ...
    def getLyapIIRanks(self) -> Any: ...
    def getMonitor(self) -> Any: ...
    def getOperators(self) -> Any: ...
    def getOptionsPrefix(self) -> Any: ...
    def getPowerShiftType(self) -> Any: ...
    def getProblemType(self) -> Any: ...
    def getPurify(self) -> Any: ...
    def getRG(self) -> Any: ...
    def getRQCGReset(self) -> Any: ...
    def getST(self) -> Any: ...
    def getStoppingTest(self) -> Any: ...
    def getTarget(self) -> Any: ...
    def getThreshold(self) -> Any: ...
    def getTolerances(self) -> Any: ...
    def getTrackAll(self) -> Any: ...
    def getTrueResidual(self) -> Any: ...
    def getTwoSided(self) -> Any: ...
    def getType(self) -> Any: ...
    def getWhichEigenpairs(self) -> Any: ...
    def isGeneralized(self) -> Any: ...
    def isHermitian(self) -> Any: ...
    def isPositive(self) -> Any: ...
    def isStructured(self) -> Any: ...
    def reset(self) -> Any: ...
    def setArbitrarySelection(self, arbitrary, args=..., kargs=...) -> Any: ...
    def setArnoldiDelayed(self, delayed) -> Any: ...
    def setBV(self, bv: BV) -> Any: ...
    def setBalance(self, balance=..., iterations=..., cutoff=...) -> Any: ...
    def setCISSExtraction(self, extraction) -> Any: ...
    def setCISSQuadRule(self, quad) -> Any: ...
    def setCISSRefinement(self, inner=..., blsize=...) -> Any: ...
    def setCISSSizes(self, ip=..., bs=..., ms=..., npart=..., bsmax=..., realmats=...) -> Any: ...
    def setCISSThreshold(self, delta=..., spur=...) -> Any: ...
    def setCISSUseST(self, usest) -> Any: ...
    def setConvergenceTest(self, conv) -> Any: ...
    def setDS(self, ds: DS) -> Any: ...
    def setDeflationSpace(self, space) -> Any: ...
    def setDimensions(self, nev=..., ncv=..., mpd=...) -> Any: ...
    def setEigenvalueComparison(self, comparison, args=..., kargs=...) -> Any: ...
    def setExtraction(self, extraction) -> Any: ...
    def setFromOptions(self) -> Any: ...
    def setGDBOrth(self, borth) -> Any: ...
    def setGDBlockSize(self, bs) -> Any: ...
    def setGDDoubleExpansion(self, doubleexp) -> Any: ...
    def setGDInitialSize(self, initialsize) -> Any: ...
    def setGDKrylovStart(self, krylovstart=...) -> Any: ...
    def setGDRestart(self, minv=..., plusk=...) -> Any: ...
    def setInitialSpace(self, space) -> Any: ...
    def setInterval(self, inta, intb) -> Any: ...
    def setJDBOrth(self, borth) -> Any: ...
    def setJDBlockSize(self, bs) -> Any: ...
    def setJDConstCorrectionTol(self, constant) -> Any: ...
    def setJDFix(self, fix) -> Any: ...
    def setJDInitialSize(self, initialsize) -> Any: ...
    def setJDKrylovStart(self, krylovstart=...) -> Any: ...
    def setJDRestart(self, minv=..., plusk=...) -> Any: ...
    def setKrylovSchurBSEType(self, bse) -> Any: ...
    def setKrylovSchurDetectZeros(self, detect) -> Any: ...
    def setKrylovSchurDimensions(self, nev=..., ncv=..., mpd=...) -> Any: ...
    def setKrylovSchurLocking(self, lock) -> Any: ...
    def setKrylovSchurPartitions(self, npart) -> Any: ...
    def setKrylovSchurRestart(self, keep) -> Any: ...
    def setKrylovSchurSubintervals(self, subint) -> Any: ...
    def setLOBPCGBlockSize(self, bs) -> Any: ...
    def setLOBPCGLocking(self, lock) -> Any: ...
    def setLOBPCGRestart(self, restart) -> Any: ...
    def setLanczosReorthogType(self, reorthog) -> Any: ...
    def setLeftInitialSpace(self, space) -> Any: ...
    def setLyapIIRanks(self, rkc=..., rkl=...) -> Any: ...
    def setMonitor(self, monitor, args=..., kargs=...) -> Any: ...
    def setOperators(self, A: Mat, B: Mat = ...) -> Any: ...
    def setOptionsPrefix(self, prefix) -> Any: ...
    def setPowerShiftType(self, shift) -> Any: ...
    def setProblemType(self, problem_type) -> Any: ...
    def setPurify(self, purify=...) -> Any: ...
    def setRG(self, rg: RG) -> Any: ...
    def setRQCGReset(self, nrest) -> Any: ...
    def setST(self, st: ST) -> Any: ...
    def setStoppingTest(self, stopping, args=..., kargs=...) -> Any: ...
    def setTarget(self, target) -> Any: ...
    def setThreshold(self, thres, rel=...) -> Any: ...
    def setTolerances(self, tol=..., max_it=...) -> Any: ...
    def setTrackAll(self, trackall) -> Any: ...
    def setTrueResidual(self, trueres) -> Any: ...
    def setTwoSided(self, twosided) -> Any: ...
    def setType(self, eps_type) -> Any: ...
    def setUp(self) -> Any: ...
    def setWhichEigenpairs(self, which) -> Any: ...
    def solve(self) -> Any: ...
    def updateKrylovSchurSubcommMats(self, s=..., a=..., Au: Mat = ..., t=..., b=..., Bu: Mat = ..., structure=..., globalup=...) -> Any: ...
    def valuesView(self, viewer: Viewer = ...) -> Any: ...
    def vectorsView(self, viewer: Viewer = ...) -> Any: ...
    def view(self, viewer: Viewer = ...) -> Any: ...

class EPSKrylovSchurBSEType:
    GRUNING: ClassVar[int] = ...
    PROJECTEDBSE: ClassVar[int] = ...
    SHAO: ClassVar[int] = ...

class FN(petsc4py.PETSc.Object):
    class CombineType:
        ADD: ClassVar[int] = ...
        COMPOSE: ClassVar[int] = ...
        DIVIDE: ClassVar[int] = ...
        MULTIPLY: ClassVar[int] = ...

    class ParallelType:
        REDUNDANT: ClassVar[int] = ...
        SYNCHRONIZED: ClassVar[int] = ...

    class Type:
        COMBINE: ClassVar[str] = ...
        EXP: ClassVar[str] = ...
        INVSQRT: ClassVar[str] = ...
        LOG: ClassVar[str] = ...
        PHI: ClassVar[str] = ...
        RATIONAL: ClassVar[str] = ...
        SQRT: ClassVar[str] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    method: Incomplete
    parallel: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def create(self, comm=...) -> Any: ...
    def destroy(self) -> Any: ...
    def duplicate(self, comm=...) -> Any: ...
    def evaluateDerivative(self, x) -> Any: ...
    def evaluateFunction(self, x) -> Any: ...
    def evaluateFunctionMat(self, A: Mat, B: Mat = ...) -> Any: ...
    def evaluateFunctionMatVec(self, A: Mat, v: Vec = ...) -> Any: ...
    def getCombineChildren(self) -> Any: ...
    def getMethod(self) -> Any: ...
    def getOptionsPrefix(self) -> Any: ...
    def getParallel(self) -> Any: ...
    def getPhiIndex(self) -> Any: ...
    def getRationalDenominator(self) -> Any: ...
    def getRationalNumerator(self) -> Any: ...
    def getScale(self) -> Any: ...
    def getType(self) -> Any: ...
    def setCombineChildren(self, comb, f1: FN, f2: FN) -> Any: ...
    def setFromOptions(self) -> Any: ...
    def setMethod(self, meth) -> Any: ...
    def setOptionsPrefix(self, prefix) -> Any: ...
    def setParallel(self, pmode) -> Any: ...
    def setPhiIndex(self, k) -> Any: ...
    def setRationalDenominator(self, alpha) -> Any: ...
    def setRationalNumerator(self, alpha) -> Any: ...
    def setScale(self, alpha=..., beta=...) -> Any: ...
    def setType(self, fn_type) -> Any: ...
    def view(self, viewer: Viewer = ...) -> Any: ...

class MFN(petsc4py.PETSc.Object):
    class ConvergedReason:
        CONVERGED_ITERATING: ClassVar[int] = ...
        CONVERGED_ITS: ClassVar[int] = ...
        CONVERGED_TOL: ClassVar[int] = ...
        DIVERGED_BREAKDOWN: ClassVar[int] = ...
        DIVERGED_ITS: ClassVar[int] = ...
        ITERATING: ClassVar[int] = ...

    class Type:
        EXPOKIT: ClassVar[str] = ...
        KRYLOV: ClassVar[str] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    bv: Incomplete
    fn: Incomplete
    max_it: Incomplete
    tol: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def appendOptionsPrefix(self, prefix) -> Any: ...
    def cancelMonitor(self) -> Any: ...
    def create(self, comm=...) -> Any: ...
    def destroy(self) -> Any: ...
    def getBV(self) -> Any: ...
    def getConvergedReason(self) -> Any: ...
    def getDimensions(self) -> Any: ...
    def getErrorIfNotConverged(self) -> Any: ...
    def getFN(self) -> Any: ...
    def getIterationNumber(self) -> Any: ...
    def getMonitor(self) -> Any: ...
    def getOperator(self) -> Any: ...
    def getOptionsPrefix(self) -> Any: ...
    def getTolerances(self) -> Any: ...
    def getType(self) -> Any: ...
    def reset(self) -> Any: ...
    def setBV(self, bv: BV) -> Any: ...
    def setDimensions(self, ncv) -> Any: ...
    def setErrorIfNotConverged(self, flg=...) -> Any: ...
    def setFN(self, fn: FN) -> Any: ...
    def setFromOptions(self) -> Any: ...
    def setMonitor(self, monitor, args=..., kargs=...) -> Any: ...
    def setOperator(self, A: Mat) -> Any: ...
    def setOptionsPrefix(self, prefix) -> Any: ...
    def setTolerances(self, tol=..., max_it=...) -> Any: ...
    def setType(self, mfn_type) -> Any: ...
    def setUp(self) -> Any: ...
    def solve(self, b: Vec, x: Vec) -> Any: ...
    def solveTranspose(self, b: Vec, x: Vec) -> Any: ...
    def view(self, viewer: Viewer = ...) -> Any: ...

class NEP(petsc4py.PETSc.Object):
    class CISSExtraction:
        CAA: ClassVar[int] = ...
        HANKEL: ClassVar[int] = ...
        RITZ: ClassVar[int] = ...

    class Conv:
        ABS: ClassVar[int] = ...
        NORM: ClassVar[int] = ...
        REL: ClassVar[int] = ...
        USER: ClassVar[int] = ...

    class ConvergedReason:
        CONVERGED_ITERATING: ClassVar[int] = ...
        CONVERGED_TOL: ClassVar[int] = ...
        CONVERGED_USER: ClassVar[int] = ...
        DIVERGED_BREAKDOWN: ClassVar[int] = ...
        DIVERGED_ITS: ClassVar[int] = ...
        DIVERGED_LINEAR_SOLVE: ClassVar[int] = ...
        DIVERGED_SUBSPACE_EXHAUSTED: ClassVar[int] = ...
        ITERATING: ClassVar[int] = ...

    class ErrorType:
        ABSOLUTE: ClassVar[int] = ...
        BACKWARD: ClassVar[int] = ...
        RELATIVE: ClassVar[int] = ...

    class ProblemType:
        GENERAL: ClassVar[int] = ...
        RATIONAL: ClassVar[int] = ...

    class Refine:
        MULTIPLE: ClassVar[int] = ...
        NONE: ClassVar[int] = ...
        SIMPLE: ClassVar[int] = ...

    class RefineScheme:
        EXPLICIT: ClassVar[int] = ...
        MBE: ClassVar[int] = ...
        SCHUR: ClassVar[int] = ...

    class Stop:
        BASIC: ClassVar[int] = ...
        USER: ClassVar[int] = ...

    class Type:
        CISS: ClassVar[str] = ...
        INTERPOL: ClassVar[str] = ...
        NARNOLDI: ClassVar[str] = ...
        NLEIGS: ClassVar[str] = ...
        RII: ClassVar[str] = ...
        SLP: ClassVar[str] = ...

    class Which:
        ALL: ClassVar[int] = ...
        LARGEST_IMAGINARY: ClassVar[int] = ...
        LARGEST_MAGNITUDE: ClassVar[int] = ...
        LARGEST_REAL: ClassVar[int] = ...
        SMALLEST_IMAGINARY: ClassVar[int] = ...
        SMALLEST_MAGNITUDE: ClassVar[int] = ...
        SMALLEST_REAL: ClassVar[int] = ...
        TARGET_IMAGINARY: ClassVar[int] = ...
        TARGET_MAGNITUDE: ClassVar[int] = ...
        TARGET_REAL: ClassVar[int] = ...
        USER: ClassVar[int] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    bv: Incomplete
    ds: Incomplete
    max_it: Incomplete
    problem_type: Incomplete
    rg: Incomplete
    target: Incomplete
    tol: Incomplete
    track_all: Incomplete
    which: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def appendOptionsPrefix(self, prefix) -> Any: ...
    def applyResolvent(self, omega, v: Vec, r: Vec, rg: RG = ...) -> Any: ...
    def cancelMonitor(self) -> Any: ...
    def computeError(self, i: int, etype=...) -> Any: ...
    def create(self, comm=...) -> Any: ...
    def destroy(self) -> Any: ...
    def errorView(self, etype=..., viewer: Viewer = ...) -> Any: ...
    def getBV(self) -> Any: ...
    def getCISSExtraction(self) -> Any: ...
    def getCISSKSPs(self) -> Any: ...
    def getCISSRefinement(self) -> Any: ...
    def getCISSSizes(self) -> Any: ...
    def getCISSThreshold(self) -> Any: ...
    def getConverged(self) -> Any: ...
    def getConvergedReason(self) -> Any: ...
    def getConvergenceTest(self) -> Any: ...
    def getDS(self) -> Any: ...
    def getDimensions(self) -> Any: ...
    def getEigenpair(self, i: int, Vr: Vec = ..., Vi: Vec = ...) -> Any: ...
    def getErrorEstimate(self, i: int) -> Any: ...
    def getFunction(self) -> Any: ...
    def getInterpolInterpolation(self) -> Any: ...
    def getInterpolPEP(self) -> Any: ...
    def getIterationNumber(self) -> Any: ...
    def getJacobian(self) -> Any: ...
    def getLeftEigenvector(self, i: int, Wr: Vec, Wi: Vec = ...) -> Any: ...
    def getMonitor(self) -> Any: ...
    def getNArnoldiKSP(self) -> Any: ...
    def getNArnoldiLagPreconditioner(self) -> Any: ...
    def getNLEIGSEPS(self) -> Any: ...
    def getNLEIGSFullBasis(self) -> Any: ...
    def getNLEIGSInterpolation(self) -> Any: ...
    def getNLEIGSKSPs(self) -> Any: ...
    def getNLEIGSLocking(self) -> Any: ...
    def getNLEIGSRKShifts(self) -> Any: ...
    def getNLEIGSRestart(self) -> Any: ...
    def getOptionsPrefix(self) -> Any: ...
    def getProblemType(self) -> Any: ...
    def getRG(self) -> Any: ...
    def getRIIConstCorrectionTol(self) -> Any: ...
    def getRIIDeflationThreshold(self) -> Any: ...
    def getRIIHermitian(self) -> Any: ...
    def getRIIKSP(self) -> Any: ...
    def getRIILagPreconditioner(self) -> Any: ...
    def getRIIMaximumIterations(self) -> Any: ...
    def getRefine(self) -> Any: ...
    def getRefineKSP(self) -> Any: ...
    def getSLPDeflationThreshold(self) -> Any: ...
    def getSLPEPS(self) -> Any: ...
    def getSLPEPSLeft(self) -> Any: ...
    def getSLPKSP(self) -> Any: ...
    def getSplitOperator(self) -> Any: ...
    def getSplitPreconditioner(self) -> Any: ...
    def getStoppingTest(self) -> Any: ...
    def getTarget(self) -> Any: ...
    def getTolerances(self) -> Any: ...
    def getTrackAll(self) -> Any: ...
    def getTwoSided(self) -> Any: ...
    def getType(self) -> Any: ...
    def getWhichEigenpairs(self) -> Any: ...
    def reset(self) -> Any: ...
    def setBV(self, bv: BV) -> Any: ...
    def setCISSExtraction(self, extraction) -> Any: ...
    def setCISSRefinement(self, inner=..., blsize=...) -> Any: ...
    def setCISSSizes(self, ip=..., bs=..., ms=..., npart=..., bsmax=..., realmats=...) -> Any: ...
    def setCISSThreshold(self, delta=..., spur=...) -> Any: ...
    def setConvergenceTest(self, conv) -> Any: ...
    def setDS(self, ds: DS) -> Any: ...
    def setDimensions(self, nev=..., ncv=..., mpd=...) -> Any: ...
    def setFromOptions(self) -> Any: ...
    def setFunction(self, function, F: Mat = ..., P: Mat = ..., args=..., kargs=...) -> Any: ...
    def setInitialSpace(self, space) -> Any: ...
    def setInterpolInterpolation(self, tol=..., deg=...) -> Any: ...
    def setInterpolPEP(self, pep: PEP) -> Any: ...
    def setJacobian(self, jacobian, J: Mat = ..., args=..., kargs=...) -> Any: ...
    def setMonitor(self, monitor, args=..., kargs=...) -> Any: ...
    def setNArnoldiKSP(self, ksp: KSP) -> Any: ...
    def setNArnoldiLagPreconditioner(self, lag) -> Any: ...
    def setNLEIGSEPS(self, eps: EPS) -> Any: ...
    def setNLEIGSFullBasis(self, fullbasis=...) -> Any: ...
    def setNLEIGSInterpolation(self, tol=..., deg=...) -> Any: ...
    def setNLEIGSLocking(self, lock) -> Any: ...
    def setNLEIGSRKShifts(self, shifts) -> Any: ...
    def setNLEIGSRestart(self, keep) -> Any: ...
    def setOptionsPrefix(self, prefix) -> Any: ...
    def setProblemType(self, problem_type) -> Any: ...
    def setRG(self, rg: RG) -> Any: ...
    def setRIIConstCorrectionTol(self, cct) -> Any: ...
    def setRIIDeflationThreshold(self, deftol) -> Any: ...
    def setRIIHermitian(self, herm) -> Any: ...
    def setRIIKSP(self, ksp: KSP) -> Any: ...
    def setRIILagPreconditioner(self, lag) -> Any: ...
    def setRIIMaximumIterations(self, its) -> Any: ...
    def setRefine(self, ref, npart=..., tol=..., its=..., scheme=...) -> Any: ...
    def setSLPDeflationThreshold(self, deftol) -> Any: ...
    def setSLPEPS(self, eps: EPS) -> Any: ...
    def setSLPEPSLeft(self, eps: EPS) -> Any: ...
    def setSLPKSP(self, ksp: KSP) -> Any: ...
    def setSplitOperator(self, A, f, structure=...) -> Any: ...
    def setSplitPreconditioner(self, P, structure=...) -> Any: ...
    def setStoppingTest(self, stopping, args=..., kargs=...) -> Any: ...
    def setTarget(self, target) -> Any: ...
    def setTolerances(self, tol=..., maxit=...) -> Any: ...
    def setTrackAll(self, trackall) -> Any: ...
    def setTwoSided(self, twosided) -> Any: ...
    def setType(self, nep_type) -> Any: ...
    def setUp(self) -> Any: ...
    def setWhichEigenpairs(self, which) -> Any: ...
    def solve(self) -> Any: ...
    def valuesView(self, viewer: Viewer = ...) -> Any: ...
    def vectorsView(self, viewer: Viewer = ...) -> Any: ...
    def view(self, viewer: Viewer = ...) -> Any: ...

class PEP(petsc4py.PETSc.Object):
    class Basis:
        CHEBYSHEV1: ClassVar[int] = ...
        CHEBYSHEV2: ClassVar[int] = ...
        HERMITE: ClassVar[int] = ...
        LAGUERRE: ClassVar[int] = ...
        LEGENDRE: ClassVar[int] = ...
        MONOMIAL: ClassVar[int] = ...

    class CISSExtraction:
        CAA: ClassVar[int] = ...
        HANKEL: ClassVar[int] = ...
        RITZ: ClassVar[int] = ...

    class Conv:
        ABS: ClassVar[int] = ...
        NORM: ClassVar[int] = ...
        REL: ClassVar[int] = ...
        USER: ClassVar[int] = ...

    class ConvergedReason:
        CONVERGED_ITERATING: ClassVar[int] = ...
        CONVERGED_TOL: ClassVar[int] = ...
        CONVERGED_USER: ClassVar[int] = ...
        DIVERGED_BREAKDOWN: ClassVar[int] = ...
        DIVERGED_ITS: ClassVar[int] = ...
        DIVERGED_SYMMETRY_LOST: ClassVar[int] = ...
        ITERATING: ClassVar[int] = ...

    class ErrorType:
        ABSOLUTE: ClassVar[int] = ...
        BACKWARD: ClassVar[int] = ...
        RELATIVE: ClassVar[int] = ...

    class Extract:
        NONE: ClassVar[int] = ...
        NORM: ClassVar[int] = ...
        RESIDUAL: ClassVar[int] = ...
        STRUCTURED: ClassVar[int] = ...

    class JDProjection:
        HARMONIC: ClassVar[int] = ...
        ORTHOGONAL: ClassVar[int] = ...

    class ProblemType:
        GENERAL: ClassVar[int] = ...
        GYROSCOPIC: ClassVar[int] = ...
        HERMITIAN: ClassVar[int] = ...
        HYPERBOLIC: ClassVar[int] = ...

    class Refine:
        MULTIPLE: ClassVar[int] = ...
        NONE: ClassVar[int] = ...
        SIMPLE: ClassVar[int] = ...

    class RefineScheme:
        EXPLICIT: ClassVar[int] = ...
        MBE: ClassVar[int] = ...
        SCHUR: ClassVar[int] = ...

    class Scale:
        BOTH: ClassVar[int] = ...
        DIAGONAL: ClassVar[int] = ...
        NONE: ClassVar[int] = ...
        SCALAR: ClassVar[int] = ...

    class Stop:
        BASIC: ClassVar[int] = ...
        USER: ClassVar[int] = ...

    class Type:
        CISS: ClassVar[str] = ...
        JD: ClassVar[str] = ...
        LINEAR: ClassVar[str] = ...
        QARNOLDI: ClassVar[str] = ...
        STOAR: ClassVar[str] = ...
        TOAR: ClassVar[str] = ...

    class Which:
        ALL: ClassVar[int] = ...
        LARGEST_IMAGINARY: ClassVar[int] = ...
        LARGEST_MAGNITUDE: ClassVar[int] = ...
        LARGEST_REAL: ClassVar[int] = ...
        SMALLEST_IMAGINARY: ClassVar[int] = ...
        SMALLEST_MAGNITUDE: ClassVar[int] = ...
        SMALLEST_REAL: ClassVar[int] = ...
        TARGET_IMAGINARY: ClassVar[int] = ...
        TARGET_MAGNITUDE: ClassVar[int] = ...
        TARGET_REAL: ClassVar[int] = ...
        USER: ClassVar[int] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    bv: Incomplete
    ds: Incomplete
    extract: Incomplete
    max_it: Incomplete
    problem_type: Incomplete
    rg: Incomplete
    st: Incomplete
    target: Incomplete
    tol: Incomplete
    track_all: Incomplete
    which: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def appendOptionsPrefix(self, prefix) -> Any: ...
    def cancelMonitor(self) -> Any: ...
    def computeError(self, i: int, etype=...) -> Any: ...
    def create(self, comm=...) -> Any: ...
    def destroy(self) -> Any: ...
    def errorView(self, etype=..., viewer: Viewer = ...) -> Any: ...
    def getBV(self) -> Any: ...
    def getBasis(self) -> Any: ...
    def getCISSExtraction(self) -> Any: ...
    def getCISSKSPs(self) -> Any: ...
    def getCISSRefinement(self) -> Any: ...
    def getCISSSizes(self) -> Any: ...
    def getCISSThreshold(self) -> Any: ...
    def getConverged(self) -> Any: ...
    def getConvergedReason(self) -> Any: ...
    def getConvergenceTest(self) -> Any: ...
    def getDS(self) -> Any: ...
    def getDimensions(self) -> Any: ...
    def getEigenpair(self, i: int, Vr: Vec = ..., Vi: Vec = ...) -> Any: ...
    def getErrorEstimate(self, i: int) -> Any: ...
    def getExtract(self) -> Any: ...
    def getInterval(self) -> Any: ...
    def getIterationNumber(self) -> Any: ...
    def getJDFix(self) -> Any: ...
    def getJDMinimalityIndex(self) -> Any: ...
    def getJDProjection(self) -> Any: ...
    def getJDRestart(self) -> Any: ...
    def getJDReusePreconditioner(self) -> Any: ...
    def getLinearEPS(self) -> Any: ...
    def getLinearExplicitMatrix(self) -> Any: ...
    def getLinearLinearization(self) -> Any: ...
    def getMonitor(self) -> Any: ...
    def getOperators(self) -> Any: ...
    def getOptionsPrefix(self) -> Any: ...
    def getProblemType(self) -> Any: ...
    def getQArnoldiLocking(self) -> Any: ...
    def getQArnoldiRestart(self) -> Any: ...
    def getRG(self) -> Any: ...
    def getRefine(self) -> Any: ...
    def getRefineKSP(self) -> Any: ...
    def getST(self) -> Any: ...
    def getSTOARCheckEigenvalueType(self) -> Any: ...
    def getSTOARDetectZeros(self) -> Any: ...
    def getSTOARDimensions(self) -> Any: ...
    def getSTOARInertias(self) -> Any: ...
    def getSTOARLinearization(self) -> Any: ...
    def getSTOARLocking(self) -> Any: ...
    def getScale(self, Dl: Vec = ..., Dr: Vec = ...) -> Any: ...
    def getStoppingTest(self) -> Any: ...
    def getTOARLocking(self) -> Any: ...
    def getTOARRestart(self) -> Any: ...
    def getTarget(self) -> Any: ...
    def getTolerances(self) -> Any: ...
    def getTrackAll(self) -> Any: ...
    def getType(self) -> Any: ...
    def getWhichEigenpairs(self) -> Any: ...
    def reset(self) -> Any: ...
    def setBV(self, bv: BV) -> Any: ...
    def setBasis(self, basis) -> Any: ...
    def setCISSExtraction(self, extraction) -> Any: ...
    def setCISSRefinement(self, inner=..., blsize=...) -> Any: ...
    def setCISSSizes(self, ip=..., bs=..., ms=..., npart=..., bsmax=..., realmats=...) -> Any: ...
    def setCISSThreshold(self, delta=..., spur=...) -> Any: ...
    def setConvergenceTest(self, conv) -> Any: ...
    def setDS(self, ds: DS) -> Any: ...
    def setDimensions(self, nev=..., ncv=..., mpd=...) -> Any: ...
    def setExtract(self, extract) -> Any: ...
    def setFromOptions(self) -> Any: ...
    def setInitialSpace(self, space) -> Any: ...
    def setInterval(self, inta, intb) -> Any: ...
    def setJDFix(self, fix) -> Any: ...
    def setJDMinimalityIndex(self, flag) -> Any: ...
    def setJDProjection(self, proj) -> Any: ...
    def setJDRestart(self, keep) -> Any: ...
    def setJDReusePreconditioner(self, flag) -> Any: ...
    def setLinearEPS(self, eps: EPS) -> Any: ...
    def setLinearExplicitMatrix(self, flag) -> Any: ...
    def setLinearLinearization(self, alpha=..., beta=...) -> Any: ...
    def setMonitor(self, monitor, args=..., kargs=...) -> Any: ...
    def setOperators(self, operators) -> Any: ...
    def setOptionsPrefix(self, prefix) -> Any: ...
    def setProblemType(self, problem_type) -> Any: ...
    def setQArnoldiLocking(self, lock) -> Any: ...
    def setQArnoldiRestart(self, keep) -> Any: ...
    def setRG(self, rg: RG) -> Any: ...
    def setRefine(self, ref, npart=..., tol=..., its=..., scheme=...) -> Any: ...
    def setST(self, st: ST) -> Any: ...
    def setSTOARCheckEigenvalueType(self, flag) -> Any: ...
    def setSTOARDetectZeros(self, detect) -> Any: ...
    def setSTOARDimensions(self, nev=..., ncv=..., mpd=...) -> Any: ...
    def setSTOARLinearization(self, alpha=..., beta=...) -> Any: ...
    def setSTOARLocking(self, lock) -> Any: ...
    def setScale(self, scale, alpha=..., Dl: Vec = ..., Dr: Vec = ..., its=..., lbda=...) -> Any: ...
    def setStoppingTest(self, stopping, args=..., kargs=...) -> Any: ...
    def setTOARLocking(self, lock) -> Any: ...
    def setTOARRestart(self, keep) -> Any: ...
    def setTarget(self, target) -> Any: ...
    def setTolerances(self, tol=..., max_it=...) -> Any: ...
    def setTrackAll(self, trackall) -> Any: ...
    def setType(self, pep_type) -> Any: ...
    def setUp(self) -> Any: ...
    def setWhichEigenpairs(self, which) -> Any: ...
    def solve(self) -> Any: ...
    def valuesView(self, viewer: Viewer = ...) -> Any: ...
    def vectorsView(self, viewer: Viewer = ...) -> Any: ...
    def view(self, viewer: Viewer = ...) -> Any: ...

class RG(petsc4py.PETSc.Object):
    class QuadRule:
        CHEBYSHEV: ClassVar[int] = ...
        TRAPEZOIDAL: ClassVar[int] = ...

    class Type:
        ELLIPSE: ClassVar[str] = ...
        INTERVAL: ClassVar[str] = ...
        POLYGON: ClassVar[str] = ...
        RING: ClassVar[str] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    complement: Incomplete
    scale: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def canUseConjugates(self, realmats=...) -> Any: ...
    def checkInside(self, a) -> Any: ...
    def computeBoundingBox(self) -> Any: ...
    def computeContour(self, n) -> Any: ...
    def computeQuadrature(self, quad, n) -> Any: ...
    def create(self, comm=...) -> Any: ...
    def destroy(self) -> Any: ...
    def getComplement(self) -> Any: ...
    def getEllipseParameters(self) -> Any: ...
    def getIntervalEndpoints(self) -> Any: ...
    def getOptionsPrefix(self) -> Any: ...
    def getPolygonVertices(self) -> Any: ...
    def getRingParameters(self) -> Any: ...
    def getScale(self) -> Any: ...
    def getType(self) -> Any: ...
    def isAxisymmetric(self, vertical=...) -> Any: ...
    def isTrivial(self) -> Any: ...
    def setComplement(self, comp=...) -> Any: ...
    def setEllipseParameters(self, center, radius, vscale=...) -> Any: ...
    def setFromOptions(self) -> Any: ...
    def setIntervalEndpoints(self, a, b, c, d) -> Any: ...
    def setOptionsPrefix(self, prefix) -> Any: ...
    def setPolygonVertices(self, v) -> Any: ...
    def setRingParameters(self, center, radius, vscale, start_ang, end_ang, width) -> Any: ...
    def setScale(self, sfactor=...) -> Any: ...
    def setType(self, rg_type) -> Any: ...
    def view(self, viewer: Viewer = ...) -> Any: ...

class ST(petsc4py.PETSc.Object):
    class MatMode:
        COPY: ClassVar[int] = ...
        INPLACE: ClassVar[int] = ...
        SHELL: ClassVar[int] = ...

    class Type:
        CAYLEY: ClassVar[str] = ...
        FILTER: ClassVar[str] = ...
        PRECOND: ClassVar[str] = ...
        SHELL: ClassVar[str] = ...
        SHIFT: ClassVar[str] = ...
        SINVERT: ClassVar[str] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    ksp: Incomplete
    mat_mode: Incomplete
    mat_structure: Incomplete
    shift: Incomplete
    transform: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def apply(self, x: Vec, y: Vec) -> Any: ...
    def applyHermitianTranspose(self, x: Vec, y: Vec) -> Any: ...
    def applyMat(self, x: Mat, y: Mat) -> Any: ...
    def applyTranspose(self, x: Vec, y: Vec) -> Any: ...
    def create(self, comm=...) -> Any: ...
    def destroy(self) -> Any: ...
    def getCayleyAntishift(self) -> Any: ...
    def getFilterDegree(self) -> Any: ...
    def getFilterInterval(self) -> Any: ...
    def getFilterRange(self) -> Any: ...
    def getKSP(self) -> Any: ...
    def getMatMode(self) -> Any: ...
    def getMatStructure(self) -> Any: ...
    def getMatrices(self) -> Any: ...
    def getOperator(self) -> Any: ...
    def getOptionsPrefix(self) -> Any: ...
    def getPreconditionerMat(self) -> Any: ...
    def getShift(self) -> Any: ...
    def getTransform(self) -> Any: ...
    def getType(self) -> Any: ...
    def reset(self) -> Any: ...
    def restoreOperator(self, op: Mat) -> Any: ...
    def setCayleyAntishift(self, tau) -> Any: ...
    def setFilterDegree(self, deg) -> Any: ...
    def setFilterInterval(self, inta, intb) -> Any: ...
    def setFilterRange(self, left, right) -> Any: ...
    def setFromOptions(self) -> Any: ...
    def setKSP(self, ksp: KSP) -> Any: ...
    def setMatMode(self, mode) -> Any: ...
    def setMatStructure(self, structure) -> Any: ...
    def setMatrices(self, operators) -> Any: ...
    def setOptionsPrefix(self, prefix) -> Any: ...
    def setPreconditionerMat(self, P: Mat = ...) -> Any: ...
    def setShift(self, shift) -> Any: ...
    def setTransform(self, flag=...) -> Any: ...
    def setType(self, st_type) -> Any: ...
    def setUp(self) -> Any: ...
    def view(self, viewer: Viewer = ...) -> Any: ...

class SVD(petsc4py.PETSc.Object):
    class Conv:
        ABS: ClassVar[int] = ...
        MAXIT: ClassVar[int] = ...
        NORM: ClassVar[int] = ...
        REL: ClassVar[int] = ...
        USER: ClassVar[int] = ...

    class ConvergedReason:
        CONVERGED_ITERATING: ClassVar[int] = ...
        CONVERGED_MAXIT: ClassVar[int] = ...
        CONVERGED_TOL: ClassVar[int] = ...
        CONVERGED_USER: ClassVar[int] = ...
        DIVERGED_BREAKDOWN: ClassVar[int] = ...
        DIVERGED_ITS: ClassVar[int] = ...
        DIVERGED_SYMMETRY_LOST: ClassVar[int] = ...
        ITERATING: ClassVar[int] = ...

    class ErrorType:
        ABSOLUTE: ClassVar[int] = ...
        NORM: ClassVar[int] = ...
        RELATIVE: ClassVar[int] = ...

    class ProblemType:
        GENERALIZED: ClassVar[int] = ...
        HYPERBOLIC: ClassVar[int] = ...
        STANDARD: ClassVar[int] = ...

    class Stop:
        BASIC: ClassVar[int] = ...
        THRESHOLD: ClassVar[int] = ...
        USER: ClassVar[int] = ...

    class TRLanczosGBidiag:
        LOWER: ClassVar[int] = ...
        SINGLE: ClassVar[int] = ...
        UPPER: ClassVar[int] = ...

    class Type:
        CROSS: ClassVar[str] = ...
        CYCLIC: ClassVar[str] = ...
        ELEMENTAL: ClassVar[str] = ...
        KSVD: ClassVar[str] = ...
        LANCZOS: ClassVar[str] = ...
        LAPACK: ClassVar[str] = ...
        PRIMME: ClassVar[str] = ...
        RANDOMIZED: ClassVar[str] = ...
        SCALAPACK: ClassVar[str] = ...
        TRLANCZOS: ClassVar[str] = ...

    class Which:
        LARGEST: ClassVar[int] = ...
        SMALLEST: ClassVar[int] = ...
    __pyx_vtable__: ClassVar[PyCapsule] = ...
    ds: Incomplete
    max_it: Incomplete
    problem_type: Incomplete
    tol: Incomplete
    track_all: Incomplete
    transpose_mode: Incomplete
    which: Incomplete
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
    def appendOptionsPrefix(self, prefix) -> Any: ...
    def cancelMonitor(self) -> Any: ...
    def computeError(self, i: int, etype=...) -> Any: ...
    def create(self, comm=...) -> Any: ...
    def destroy(self) -> Any: ...
    def errorView(self, etype=..., viewer: Viewer = ...) -> Any: ...
    def getBV(self) -> Any: ...
    def getConverged(self) -> Any: ...
    def getConvergedReason(self) -> Any: ...
    def getConvergenceTest(self) -> Any: ...
    def getCrossEPS(self) -> Any: ...
    def getCrossExplicitMatrix(self) -> Any: ...
    def getCyclicEPS(self) -> Any: ...
    def getCyclicExplicitMatrix(self) -> Any: ...
    def getDS(self) -> Any: ...
    def getDimensions(self) -> Any: ...
    def getImplicitTranspose(self) -> Any: ...
    def getIterationNumber(self) -> Any: ...
    def getLanczosOneSide(self) -> Any: ...
    def getMonitor(self) -> Any: ...
    def getOperators(self) -> Any: ...
    def getOptionsPrefix(self) -> Any: ...
    def getProblemType(self) -> Any: ...
    def getSignature(self, omega: Vec = ...) -> Any: ...
    def getSingularTriplet(self, i: int, U: Vec = ..., V: Vec = ...) -> Any: ...
    def getStoppingTest(self) -> Any: ...
    def getTRLanczosExplicitMatrix(self) -> Any: ...
    def getTRLanczosGBidiag(self) -> Any: ...
    def getTRLanczosKSP(self) -> Any: ...
    def getTRLanczosLocking(self) -> Any: ...
    def getTRLanczosOneSide(self) -> Any: ...
    def getTRLanczosRestart(self) -> Any: ...
    def getThreshold(self) -> Any: ...
    def getTolerances(self) -> Any: ...
    def getTrackAll(self) -> Any: ...
    def getType(self) -> Any: ...
    def getValue(self, i: int) -> Any: ...
    def getVectors(self, i: int, U: Vec, V: Vec) -> Any: ...
    def getWhichSingularTriplets(self) -> Any: ...
    def isGeneralized(self) -> Any: ...
    def isHyperbolic(self) -> Any: ...
    def reset(self) -> Any: ...
    def setBV(self, V: BV, U: BV = ...) -> Any: ...
    def setConvergenceTest(self, conv) -> Any: ...
    def setCrossEPS(self, eps: EPS) -> Any: ...
    def setCrossExplicitMatrix(self, flag=...) -> Any: ...
    def setCyclicEPS(self, eps: EPS) -> Any: ...
    def setCyclicExplicitMatrix(self, flag=...) -> Any: ...
    def setDS(self, ds: DS) -> Any: ...
    def setDimensions(self, nsv=..., ncv=..., mpd=...) -> Any: ...
    def setFromOptions(self) -> Any: ...
    def setImplicitTranspose(self, mode) -> Any: ...
    def setInitialSpaces(self, spaceright=..., spaceleft=...) -> Any: ...
    def setLanczosOneSide(self, flag=...) -> Any: ...
    def setMonitor(self, monitor, args=..., kargs=...) -> Any: ...
    def setOperator(self, *args, **kwargs): ...
    def setOperators(self, A: Mat, B: Mat = ...) -> Any: ...
    def setOptionsPrefix(self, prefix) -> Any: ...
    def setProblemType(self, problem_type) -> Any: ...
    def setSignature(self, omega: Vec = ...) -> Any: ...
    def setStoppingTest(self, stopping, args=..., kargs=...) -> Any: ...
    def setTRLanczosExplicitMatrix(self, flag=...) -> Any: ...
    def setTRLanczosGBidiag(self, bidiag) -> Any: ...
    def setTRLanczosKSP(self, ksp: KSP) -> Any: ...
    def setTRLanczosLocking(self, lock) -> Any: ...
    def setTRLanczosOneSide(self, flag=...) -> Any: ...
    def setTRLanczosRestart(self, keep) -> Any: ...
    def setThreshold(self, thres, rel=...) -> Any: ...
    def setTolerances(self, tol=..., max_it=...) -> Any: ...
    def setTrackAll(self, trackall) -> Any: ...
    def setType(self, svd_type) -> Any: ...
    def setUp(self) -> Any: ...
    def setWhichSingularTriplets(self, which) -> Any: ...
    def solve(self) -> Any: ...
    def valuesView(self, viewer: Viewer = ...) -> Any: ...
    def vectorsView(self, viewer: Viewer = ...) -> Any: ...
    def view(self, viewer: Viewer = ...) -> Any: ...

class Sys:
    getVersion: ClassVar[method] = ...
    getVersionInfo: ClassVar[method] = ...
    hasExternalPackage: ClassVar[method] = ...
    isFinalized: ClassVar[method] = ...
    isInitialized: ClassVar[method] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...

class Util:
    createMatBSE: ClassVar[method] = ...
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...

class _p_mem:
    @classmethod
    def __init__(cls, *args, **kwargs) -> None: ...
